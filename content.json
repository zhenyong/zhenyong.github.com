{"meta":{"title":"Make Hungry","subtitle":"饥渴难耐","description":null,"author":"huáng zhèn yǒng","url":"http://zhenyong.site"},"pages":[{"title":"","date":"2016-09-05T09:05:29.000Z","updated":"2016-09-05T09:05:29.000Z","comments":true,"path":"css-examples/index.html","permalink":"http://zhenyong.site/css-examples/index.html","excerpt":"","text":""},{"title":"about","date":"2016-07-23T08:01:08.000Z","updated":"2016-07-23T08:01:08.000Z","comments":true,"path":"about/index.html","permalink":"http://zhenyong.site/about/index.html","excerpt":"","text":""},{"title":"Docs","date":"2016-10-07T06:10:49.000Z","updated":"2016-10-07T06:10:49.000Z","comments":true,"path":"docs/index.html","permalink":"http://zhenyong.site/docs/index.html","excerpt":"","text":"vue-vuex 中文文档vue-router 中文文档vue-loader 中文文档React 中文文档Flow 中文文档"},{"title":"All tags","date":"2016-07-23T07:51:33.000Z","updated":"2016-07-23T07:54:51.000Z","comments":false,"path":"tags/index.html","permalink":"http://zhenyong.site/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2016-07-23T08:08:53.000Z","updated":"2016-07-23T08:16:47.000Z","comments":false,"path":"categories/index.html","permalink":"http://zhenyong.site/categories/index.html","excerpt":"","text":""},{"title":"","date":"2016-09-05T09:04:22.000Z","updated":"2016-09-05T09:04:22.000Z","comments":true,"path":"css-examples/layout/holy-grail/holy-grail-mul.html","permalink":"http://zhenyong.site/css-examples/layout/holy-grail/holy-grail-mul.html","excerpt":"","text":"#ct { width: 800px; border: 1px solid; padding-right: 310px; padding-left: 310px; box-sizing: border-box; } #ct::after{ display: block; clear: both; visibility: hidden; height: 0; content: ''; } main { background: red; float: left; width: 100%; } nav#left { background: blue; width: 300px; float: left; position: relative; left: -310px; margin-left: -100%; } nav#right { background: yellow; width: 300px; float: left; position: relative; margin-left: -300px; right: -310px; } 主内容主内 左侧边栏 右侧边栏 ___ **CC BY-NC-SA 3.0 CN** 本著作采用 [署名-非商业性使用-相同方式共享 3.0 中国大陆](https://creativecommons.org/licenses/by-nc-sa/3.0/cn/) 进行许可 欢迎转载，但转载请注明来自 [zhenyong.site](http://zhenyong.site)，并保持转载后文章内容的完整"},{"title":"","date":"2016-09-05T09:04:26.000Z","updated":"2016-09-05T09:04:26.000Z","comments":true,"path":"css-examples/layout/holy-grail/holy-grail-right.html","permalink":"http://zhenyong.site/css-examples/layout/holy-grail/holy-grail-right.html","excerpt":"","text":"#ct { width: 800px; border: 1px solid; padding-right: 310px; box-sizing: border-box; } #ct::after{ display: block; clear: both; visibility: hidden; height: 0; content: ''; } main { background: red; float: left; width: 100%; } nav { background: yellow; width: 300px; float: left; position: relative; margin-left: -300px; right: -310px; } 主内容主内容主内容主内容主内容主内容主内容主内容主内容主内容主内容主内容主内容主内容主 内容主内容主内容主内容 侧边栏 ___ **CC BY-NC-SA 3.0 CN** 本著作采用 [署名-非商业性使用-相同方式共享 3.0 中国大陆](https://creativecommons.org/licenses/by-nc-sa/3.0/cn/) 进行许可 欢迎转载，但转载请注明来自 [zhenyong.site](http://zhenyong.site)，并保持转载后文章内容的完整"},{"title":"","date":"2016-09-05T09:04:36.000Z","updated":"2016-09-05T09:04:36.000Z","comments":true,"path":"css-examples/layout/holy-grail/holy-grail.html","permalink":"http://zhenyong.site/css-examples/layout/holy-grail/holy-grail.html","excerpt":"","text":"#ct { width: 800px; border: 1px solid; padding-left: 310px; box-sizing: border-box; } #ct::after{ display: block; clear: both; visibility: hidden; height: 0; content: ''; } main { background: red; float: left; width: 100%; } nav { background: yellow; width: 300px; float: left; position: relative; left: -310px; margin-left: -100%; } 主内容主内容主内容主内容主内容主内容主内容主内容主内容主内容主内容主内容主内容主内容主 内容主内容主内容主内容 侧边栏 ## 圣杯布局的优势: - main 容宽度完全自适应 - 没有脱离文档流，ct 高度可以被 nav 和 main 撑开 ## 理解难点： 当 main 宽度为 100% 时，同为 float:left 的 nav 跟在 main 后面，因为塞不下就会变为下一行， 此时为 nav 设置 margin-left:-100% (容器的100%)，此时 main 同行也能容纳 nav 了，且两者 开头位置重叠，于是乎继续用 left: -310px 把它放到最左侧 ___ **CC BY-NC-SA 3.0 CN** 本著作采用 [署名-非商业性使用-相同方式共享 3.0 中国大陆](https://creativecommons.org/licenses/by-nc-sa/3.0/cn/) 进行许可 欢迎转载，但转载请注明来自 [zhenyong.site](http://zhenyong.site)，并保持转载后文章内容的完整"}],"posts":[{"title":"你用 webpack 1.x 输出的 hash 靠谱不？","slug":"webpack-long-term-hash","date":"2016-10-27T11:05:08.000Z","updated":"2016-10-28T02:28:35.000Z","comments":true,"path":"2016/10/27/webpack-long-term-hash/","link":"","permalink":"http://zhenyong.site/2016/10/27/webpack-long-term-hash/","excerpt":"使用 webpack 构建输出文件时，通常会给文件名加上 hash，该 hash 值根据文件内容计算得到，只要文件内容不变，hash 就不变，于是就可以利用浏览器缓存来节省下载流量。可是 webpack 提供的 hash 似乎不那么靠谱…","text":"使用 webpack 构建输出文件时，通常会给文件名加上 hash，该 hash 值根据文件内容计算得到，只要文件内容不变，hash 就不变，于是就可以利用浏览器缓存来节省下载流量。可是 webpack 提供的 hash 似乎不那么靠谱… 本文只围绕如何保证 webpack 1.x 在 生产发布阶段 输出稳定的 hash 值展开讨论，如果对 webpack 还没了解的，可以戳 webpack。 本文 基于 webpack 1.x 的背景展开讨论，毕竟有些问题在 webpack 2 已经得到解决。为了方便描述问题，文中展示的代码、配置可能很挫，也许不是工程最佳实践，请轻拍。 目标除了 html 文件以外，其他静态资源文件名都带上哈希值，根据文件本身的内容计算得到，保证文件没变化，则构建后的文件名跟上次一样。 webpack 提供的 hash[hash]假设文件目录长这样： 123/src |- pageA.js (入口1) |- pageB.js (入口2) 使用 webpack 配置:123456789entry: &#123; pageA: './src/pageA.js', pageB: './src/pageB.js',&#125;,output: &#123; path: __dirname + '/build', // [hash:4] 表示截取 [hash] 前四位 filename: '[name].[hash:4].js'&#125;, 首次构建输出: 12pageA.c56c.js 1.47 kB 0 [emitted] pageApageB.c56c.js 1.47 kB 1 [emitted] pageB 再次构建输出：12pageA.c56c.js 1.47 kB 0 [emitted] pageApageB.c56c.js 1.47 kB 1 [emitted] pageB hash 值是稳定的呀，是不是就可以了呢？且慢！ 根据 Configuration · webpack/docs Wiki ： [hash] is replaced by the hash of the compilation. 意译： [hash] 是根据一个 compilation 对象计算得出的哈希值，如果 compilation 对象的信息不变，则 [hash] 不变 结合 how to write a plugin 提到： A compilation object represents a single build of versioned assets. While running Webpack development middleware, a new compilation will be created each time a file change is detected, thus generating a new set of compiled assets. A compilation surfaces information about the present state of module resources, compiled assets, changed files, and watched dependencies. 意译： compilation 对象代表对某个版本进行一次编译构建的过程，如果在开发模式下（例如用 –watch 检测变化，实时编译），则每次内容变化时会新建一个 complidation，包含了构建所需的上下文信息（构建器配置、文件、文件依赖）。 我们来动一下 pageA.js，再次构建： 12pageA.e6a9.js 1.48 kB 0 [emitted] pageApageB.e6a9.js 1.47 kB 1 [emitted] pageB 发现 hash 变了，并且所有文件的 hash 值总是一样，这似乎就跟文档描述的一致，只要构建过程依赖的任何资源（代码）发生变化，compilation 的信息就会跟上一次不一样了。 那是不是肯定说，源码不变的话，hash 值就一定稳定呢？也不是的，我们改一下 webpack 配置： 12345entry: &#123; pageA: './src/pageA.js', // 不再构建入口 pageB // pageB: './src/pageB.js',&#125;, 再次构建：1pageA.1f01.js 1.48 kB 0 [emitted] pageA compilation 的信息还包括构建上下文，所以，移除入口或者换个loader 都会引起 hash 改变。 [hash] 的缺点很明显，不是根据内容来计算哈希，但是 hash 值是”稳定的”，用这种方案能保证『每次上线，浏览器访问到的静态资源都是新的（url 变了）』 你接受用 [hash] 吗，我是接受不了？于是我们看 webpack 提供的另一种根据内容计算 hash 的配置。 [chunkhash] [chunkhash] is replaced by the hash of the chunk. 意译： [chunkhash] 根据 chunk 的内容计算得到。（chunk 可以理解成一个输出文件，其中可能包含多个 js 模块） 我们改下配置： 12345678entry: &#123; pageA: &apos;./src/pageA.js&apos;, pageB: &apos;./src/pageB.js&apos;,&#125;,output: &#123; path: __dirname + &apos;/build&apos;, filename: &apos;[name].[chunkhash:4].js&apos;,&#125;, 构建试试： 12pageA.f308.js 1.48 kB 0 [emitted] pageApageB.53a9.js 1.47 kB 1 [emitted] pageB 动下 pageA.js 再构建： 12pageA.16d6.js 1.48 kB 0 [emitted] pageApageB.53a9.js 1.47 kB 1 [emitted] pageB 发现只有 pageA 的 hash 变了，似乎 [chunkhash] 就能解决问题了？且慢！ 我们目前的代码没涉及到 css，先加点 css 文件依赖： 123456/src |- pageA.js |- pageA.css//pageA.jsrequire(&apos;./a.css&apos;); 给 webpack 配置 css 文件的 loader，并且抽取所有样式输出到一个文件12345678910module: &#123; loaders: [&#123; test: /\\.css$/, loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader&apos;) &#125;],&#125;,plugins: [ // 这里的 contenthash 是 ExtractTextPlugin 根据抽取输出的文件内容计算得到 new ExtractTextPlugin(&apos;[name].[contenthash:4].css&apos;)], 构建： 12pageA.ab4b.js 1.6 kB 0 [emitted] pageApageA.b9bc.css 36 bytes 0 [emitted] pageA 改一下样式，那么样式的 hash 肯定会变的，那 pageA.js 的 hash 变不变呢? 答案是『变了』： 12pageA.0482.js 1.6 kB 0 [emitted] pageApageA.c61a.css 31 bytes 0 [emitted] pageA 记得之前说 webpack 的 [chunkhash] 是根据 chunk 的内容计算的，而 pageA.js 这个 chunk 的输出在 webpack 看来是包括 css 文件的，只不过被你抽取出来罢了，所以你改 css 也就改了这个 chunk 的内容，这体验很不好吧，怎么让 css 不影响 js 的 hash 呢？ 自定义 chunkhash源码 webpack/Compilation.js： 1234...this.applyPlugins(&quot;chunk-hash&quot;, chunk, chunkHash);chunk.hash = chunkHash.digest(hashDigest);... 通过这段代码可以发现，通过在 ‘chunk-hash’ “钩子” 中替换掉 chunk 的 digest 方法，就可以自定义 chunk.hash 了。 查看文档 how to write a plugin 了解怎么写插件来注册一个钩子方法： 12345678910111213141516171819plugins: [ ... new ContentHashPlugin() // 添加插件（生产发布阶段使用） ],&#125;;// 插件函数function ContentHashPlugin() &#123;&#125;// webpack 会执行插件函数的 apply 方法ContentHashPlugin.prototype.apply = function(compiler) &#123; compiler.plugin('compilation', function(compilation) &#123; compilation.plugin('chunk-hash', function(chunk, chunkHash) &#123; // 这里注册了之前说到的 'chunk-hash' 钩子 chunk.digest = function () &#123; return '这就是自定义的 hash 值'; &#125; &#125;); &#125;);&#125;; 那么这个 hash 值如何计算好呢？ 可以将 chunk 所依赖的各个模块 (单个源码文件) 的内容拼接后计算一个 md5 作为 hash 值，当然需要对所有文件排序后再拼接： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var crypto = require('crypto');var md5Cache = &#123;&#125;function md5(content) &#123; if (!md5Cache[content]) &#123; md5Cache[content] = crypto.createHash('md5') // .update(content, 'utf-8').digest('hex') &#125; return md5Cache[content];&#125;function ContentHashPlugin() &#123;&#125;ContentHashPlugin.prototype.apply = function(compiler) &#123; var context = compiler.options.context; function getModFilePath(mod) &#123; // 获取形如 './src/pageA.css' 这样的路径 // libIdent 方法会处理好不同平台的路径分隔符问题 return mod.libIdent(&#123; context: context &#125;); &#125; // 根据模块对应的文件路径排序 //（可以根据模块ID，但是暂时不靠谱，后面会讲） function compareMod(modA, modB) &#123; var modAPath = getModFilePath(modA); var modBPath = getModFilePath(modB); return modAPath &gt; modBPath ? 1 : modAPath &lt; modBPath ? -1 : 0; &#125; // 获取模块源码，开发阶段别用 function getModSrc(mod) &#123; return mod._source &amp;&amp; mod._source._value || ''; &#125; compiler.plugin(\"compilation\", function(compilation) &#123; compilation.plugin(\"chunk-hash\", function(chunk, chunkHash) &#123; var source = chunk.modules.sort(compareMod).map(getModSrc).join(''); chunkHash.digest = function() &#123; return md5(source); &#125;; &#125;); &#125;);&#125;;module.exports = ContentHashPlugin; 此时，pageA.css 修改之后，再也不会影响 pageA.js 的 hash 值。 另外要注意，ExtractTextPlugin 会把 pageA.css 的内容抽取之后，替换该模块的内容 mod._source._value 为： 1// removed by extract-text-webpack-plugin 由于每一个 css 模块都对应这段内容，所以不会影响效果。 erm0l0v/webpack-md5-hash 插件也是为了解决类似问题，但是它其中的『排序』算法是基于模块的 id，而模块的 id 理论上是不稳定的，接下来我们就讨论不稳定的模块 ID 带来的坑。 模块 ID 的坑我们简单的把每个文件理解为一个模块（module），在 webpack 处理模块依赖关系时，会给每个模块定义一个 ID，查看 webpack/Compilation.js 发现，webpack 根据收集 module 的顺序给每个模块分配递增数字作为 ID，至于『收集的 module 顺序』，在你开发生涯里，这玩意绝对是不稳定！不稳定的！ Module ID 不稳定怎么了我们的文件结构现在长这样： 123456/src |- pageA.js |- pageB.js |- a.js |- b.js |- c.js pageA.js 123require('./a.js') // a.jsrequire('./b.js') // b.jsvar a = 'this is pageA'; pageB.js 123require('./b.js') // b.js'require('./c.js') // c.jsvar b = 'this is pageB'; 更新配置，把引用达到 2 次的模块抽取出来： 12345678910 output: &#123; chunkFilename: \"[id].[chunkhash:4].bundle.js\", ...plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: \"commons\", minChunks: 2, chunks: [\"pageA\", \"pageB\"], &#125;), ... build build build: 123 pageA.1cda.js 262 bytes 0 [emitted] pageA pageB.0752.js 280 bytes 1 [emitted] pageBcommons.14bf.js 3.64 kB 2 [emitted] commons 观察 pageB.0752.js，有一段: 123__webpack_require__(2) // b.js'__webpack_require__(3) // c.jsvar b = 'this is pageB'; 从上面看出，webpack 构建时给 b.js 的模块 ID 为 2 这时，我们改一下 pageA.js： 1234// 移除对 a.js 的依赖// require(&apos;./a.js&apos;) // a.jsrequire(&apos;./b.js&apos;) // b.jsvar a = &apos;this is pageA&apos;; build build build ： 123 pageA.a945.js 200 bytes 0 [emitted] pageA pageB.0752.js 271 bytes 1 [emitted] pageBcommons.14bf.js 3.65 kB 2 [emitted] commons 嗯! 只有 pageA.js 的 hash 变了，挺合理合理，我们进去 pageB.0752.js 看看 123__webpack_require__(1) // b.js'__webpack_require__(2) // c.jsvar b = 'this is pageB'; 看出来了没！这次构建，webpack 给 b.js 的 ID 是 1。 我们 pageB.js 的 hash 没变，因为背后依赖的模块内容 (b.js、c.js) 没有变呀，但是此时 pageB.0752.js 的内容确实变了，如果你用 CDN 上传这个文件，也许会传不上去，因为文件大小和名称一模一样，就是这个不稳定的模块 ID 给坑的！ 怎么解决呢？ 第一念头：把原来计算 hash 的方式改一下，就那构建输出后的文件内容来计算？ 细想: 不要，明明 pageB 这一次就不用重新上传的，浪费。 比较优雅的思路就是：让模块 ID 给我稳定下来！！！ 给我稳定的 Module IDwebpack 1 的官方方案webpack 文档提供了几种方案 OccurrenceOrderPlugin 这个插件根据 module 被引用的次数（被 entry 引用、被 chunk 引用）来排序分配 ID，如果你的整个应用的文件依赖是没太多变化，那么模块 ID 就稳定，但是谁能保证呢？ recordsPath 配置 Store/Load compiler state from/to a json file. This will result in persistent ids of modules and chunks. 会记录每一次打包的模块的”文件处理路径”使用的 ID，下次打包同样的模块直接使用记录中的 ID: 1&quot;node_modules/style-loader/index.js!node_modules/css-loader/index.js!src/b.css&quot;: 9, 这就要求每个人都得提交这份文件了，港真，我觉得体验很差咯。 另外一旦你修改文件名，或者是增减 loader，原来的路径就无效了，从而再次入坑！ DllPlugin 和 DllReferencePlugin 原理就是在你打包源码前，你得新建一个构建配置用 DllPlugin 单独打包生成一份模块文件路径对应的 ID 记录，然后在你的原来配置使用 DllReferencePlugin 引用这份记录，跟 recordsPath 大同小异，但是更高效和稳定，但是这个额外的构建，我觉得不够优雅，至于能快多少呢，我目前还不在意这个速度，另外还是得提交多一份记录文件。 webpack 2 的思路 webpack/HashedModuleIdsPlugin.js at master · webpack/webpack webpack/NamedModulesPlugin.js at master · webpack/webpack 以上两个插件的思路都是用模块对应的文件路径直接作为模块 ID，而不是 webpack 1 中的默认使用数字，另外 webpack 1 不接受非数字作为 模块 ID。 我们的思路把模块对应的文件路径通过一个哈希计算映射为数字，用这个全局唯一的数字作为 ID 就解决了，妥妥的！ 参考： webpack/Compilation.js 中暴露的 before-module-ids 钩子 webpack/HashedModuleIdsPlugin.js 给出 webpack 1.x 中的解决方案： 1234567891011121314151617181920212223242526272829303132333435363738394041424344...xx.prototype.apply = function(compiler) &#123; function hexToNum(str) &#123; str = str.toUpperCase(); var code = &apos;&apos; for (var i = 0; i &lt; str.length; i++) &#123; var c = str.charCodeAt(i) + &apos;&apos;; if ((c + &apos;&apos;).length &lt; 2) &#123; c = &apos;0&apos; + c &#125; code += c &#125; return parseInt(code, 10); &#125; var usedIds = &#123;&#125;; function genModuleId(module) &#123; var modulePath = module.libIdent(&#123; context: compiler.options.context &#125;); var id = md5(modulePath); var len = 4; while (usedIds[id.substr(0, len)]) &#123; len++; &#125; id = id.substr(0, len); return hexToNum(id) &#125; compiler.plugin(&quot;compilation&quot;, function(compilation) &#123; compilation.plugin(&quot;before-module-ids&quot;, function(modules) &#123; modules.forEach(function(module) &#123; if (module.libIdent &amp;&amp; module.id === null) &#123; module.id = genModuleId(module); usedIds[module.id] = true; &#125; &#125;); &#125;); &#125;);&#125;;... 注册钩子的思路跟之前的 content hash 插件差不多，获取到模块文件路径后，通过 md5 计算输出 16 进制的字符串（[0-9A-E]），再把字符串的字符逐个转为 ascii 形式的整数，由于 16 进制字符串只会包含 [0-9A-E]，所以保证单个字符转化的整数是两位就能保证这个算法是有效的。 举例: 123path = &apos;/node_module/xxx&apos;md5Hash = md5(path) // =&gt; A3E...nul = hexToNum(md5Hash) // =&gt; 650369 这个方案还有些小缺点，就是用模块文件路径作为哈希输入还不是百分百完美，如果文件名改了，那么模块 ID 就 “不稳定了”。其实，可以用模块文件内容作为哈希输入，考虑到效率问题，权衡之下还是用路径好了。 总结为了保证 webpack 1.x 生产阶段的文件 hash 值能够完美跟文件内容一一映射，查阅了大量信息，根据目前 github 上讨论的解决方案算是大体解决了问题，但是还不够优雅和完美，于是借鉴 webpack 2 的思路加上一点小技巧，比较优雅地解决了这个问题。 参考资料 Vendor chunkhash changes when app code changes · Issue #1315 · webpack/webpack Vendor chunkhash changes when app code changes · Issue #1315 · webpack/webpack Webpack中hash与chunkhash的区别，以及js与css的hash指纹解耦方案 - zhoujunpeng - 博客园 webpack使用优化 | Web前端 腾讯AlloyTeam Blog | 愿景: 成为地球卓越的Web团队！ CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[{"name":"tech","slug":"tech","permalink":"http://zhenyong.site/categories/tech/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://zhenyong.site/tags/webpack/"}]},{"title":"Vue 2 相关库的中文翻译","slug":"vue-next-stack-doc","date":"2016-10-07T06:15:35.000Z","updated":"2016-10-07T06:18:14.000Z","comments":true,"path":"2016/10/07/vue-next-stack-doc/","link":"","permalink":"http://zhenyong.site/2016/10/07/vue-next-stack-doc/","excerpt":"","text":"Vue 2 相关库 vue-router@next 和 vuex@next 的中文翻译 vue-router vuex CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[{"name":"tech","slug":"tech","permalink":"http://zhenyong.site/categories/tech/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://zhenyong.site/tags/vue/"},{"name":"git","slug":"git","permalink":"http://zhenyong.site/tags/git/"}]},{"title":"开始折腾 Atom","slug":"starting-atom","date":"2016-08-03T05:05:49.000Z","updated":"2016-08-05T04:15:03.000Z","comments":true,"path":"2016/08/03/starting-atom/","link":"","permalink":"http://zhenyong.site/2016/08/03/starting-atom/","excerpt":"Atom 是 Github 出品，基于 Electron 开发的跨平台编辑器。 之前是 Sublime 重度使用者，因为 React Native 出了个只支持 Atom 的插件，于是开始折腾 Atom，以前没用是因为它太慢了，一个月卸三次装三次，目前 1.9 版本性能提升了好多，插件都是基于 JS，目前插件数量跟 Sublime 的差不多，毕竟是基于浏览器，使用的技术都是前端熟悉的。 那么，从更换主题开始吧…","text":"Atom 是 Github 出品，基于 Electron 开发的跨平台编辑器。 之前是 Sublime 重度使用者，因为 React Native 出了个只支持 Atom 的插件，于是开始折腾 Atom，以前没用是因为它太慢了，一个月卸三次装三次，目前 1.9 版本性能提升了好多，插件都是基于 JS，目前插件数量跟 Sublime 的差不多，毕竟是基于浏览器，使用的技术都是前端熟悉的。 那么，从更换主题开始吧… 更换主题下面是原来 Sublime 使用的界面主题和语法颜色，很高大上： 12&quot;theme&quot;: &quot;Material-Theme.sublime-theme&quot;,&quot;color_scheme&quot;: &quot;Packages/User/SublimeLinter/Oceanic Next (SL).tmTheme&quot; 在 Atom 中安装界面主题 material-ui 和语法颜色 oceanic-next，文档说的很详细 修改主题使用了上面的主题和颜色后，发现编辑区的背景颜色跟 sublime 用的不一样，因为 Atom 本质上是个 Chrome 浏览，第一个想法就是调出控制台 (alt+cmd+i)，查看这个节点 atom-text-editor 的样式 ，接着按照 material-ui 的文档修改主题： 1234567// styles/editor.lessatom-text-editor &#123; // 注释掉这行就好了 // background: @level-3-color; ...&#125; 如果擅长前端的童鞋用 Atom 上手会很高效，这玩意就是个浏览器，^_^ ！ 插件们 EditorConfig Atom 内置 whitespace 插件会『覆盖』掉 EditorConfig 配置，导致 trim_trailing_whitespace 和 insert_final_newline 在 .editorconfig 中无效，参考 github issue (##2016-08-03##) Markdown markdown-previwe 内置的 markdown-previwe 很好用，（shift+ctrl+m）打开实时预览，还能设置 github 的样式，很酷 markdown-scroll-sync 让预览视图随着编辑光标位置滚动，滚的很准！ Linter 错误提示的 UI 做的真好 linter-eslint linter-flow 如果安装了 nuclide 会引发配置错误提示，参考这里 问题不大，但是每次出现很烦，所以 Disable linter-flow，反正 nuclide 本身有 nuclide-flow 支持 Flow 检测 hyperclick 点击文本跳转的基础，支持各类扩展跳转，如安装 js-hyperclick 插件支持变量定义跳转等 js-hyperclick JS 点击变量跳转到定义处…强大到远超我想像 atom-ternjs 代码智能提示，还支持 ES6，它是会扫描代码作分析的，快赶上 IDE了。 highlight-selected 选中文本后，高亮其他相同文本，双击变量最实用 autocomplete-paths require、src 等路径提示 docblockr 愉快的写注释文档，包括方法等… regex-railroad-diagram 选中正则之后，展示可视化的匹配路径，酷~ file-icons 导航区文件图标，图标齐全好看 emmet 手写 HTML 的神器，有个快捷键会跟 markdown preview 冲突，参考这里 local-history 本地记录文件历史 pigments 颜色相关工具，包括：把rgb(x,x,x)背景色变成相应颜色，选色…牛 atom-beautify 代码格式化，支持巨多语言 auto-update-packages 自动更新插件，虽然设置里面点一下就可以，但是自动不更好吗 git-projects 快速打开本地 git 项目，省得切换一次命令行 minimap 像 Sublime 那样在右侧有个全景代码小图，支持很多扩展 language-babel 语法支持 ES6、JSX、Flow …，还支持预览 babel 或 react 编译结果 (nuclide)[https://atom.io/packages/nuclide] 帮助开发 ReactNative、Flow 相关项目，装完感觉更像 IDE nuclide 的 tree-view 覆盖原来的，所有原来 tree-view 上 git 状态颜色就看不到，参考这里，不用 nuclide 的 tree-view， 同时也失去它的 remote file sync 等功能 (open-recent)[https://atom.io/packages/open-recent] 像 Sublime 的 File -&gt; Open Recent，搞不懂为啥不内置 (react)[https://atom.io/packages/react] JSX 语法高亮、格式化…最喜欢的事 HTML-&gt;JSX (term3)[https://atom.io/packages/term3] 终端 (todo-show)[https://atom.io/packages/todo-show] 找出所有 // TODO (tool-bar)[https://atom.io/packages/tool-bar] 让 Atom 支持 toolbar，需要安装其他扩展插件 (Advanced Open File)[https://atom.io/packages/advanced-open-file] 快速打开硬盘上某个文件，如果不存在则创建，支持相对项目路径，创建多个文件，真方便 (keybinding-resolver)[https://atom.io/packages/keybinding-resolver] 查看快捷键对应哪些命令，命令冲突时最好用了 Git (git-plus)[https://atom.io/packages/git-plus] 便捷 git 操作 (merge-conflicts)[https://atom.io/packages/merge-conflicts] merge 冲突的时候，用上它方便逐个修改冲突 (source-preview)[https://atom.io/packages/source-preview] 转化后的代码预览，是一个基础插件，需要配合其他 provider 插件 疑难杂症 安装插件速度慢 在 ~/.atom/.apmrc 配置 npm 镜像 1registry = https://registry.npm.taobao.org 或者命令行 1apm config set registry https://registry.npm.taobao.org CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[],"tags":[{"name":"Atom","slug":"Atom","permalink":"http://zhenyong.site/tags/Atom/"}]},{"title":"Vuex 笔记之 Q & A","slug":"vuex-q-and-a","date":"2016-07-30T07:16:51.000Z","updated":"2016-07-30T07:43:20.000Z","comments":true,"path":"2016/07/30/vuex-q-and-a/","link":"","permalink":"http://zhenyong.site/2016/07/30/vuex-q-and-a/","excerpt":"Vuex 借鉴 Flux 开发思想，帮助你用更好的程序架构开发 Vue.js 应用，主要体现在帮你更好地管理状态。 通过『提问』和『回答』的方式记录 文档 笔记：","text":"Vuex 借鉴 Flux 开发思想，帮助你用更好的程序架构开发 Vue.js 应用，主要体现在帮你更好地管理状态。 通过『提问』和『回答』的方式记录 文档 笔记： 数据存储在哪里？整个应用的状态数据存储在一个单例 store 中 组件怎么获取状态？组件要使用状态（getter of state）则在组件引入 vuex 配置，为每个coputed 变量指定一个 getter 方法，方法的第一个参数总是 state，然后返回你要的 怎么修改状态？谨记组件的状态 getter 不要做任何直接修改状态的事情，或者是触发其他有副作用的事件等。想管理状态则触发 mutation，真正给 state 动刀的是在 vuex。每当你需要管理状态时，每个改变都可以定义成一个『命令』，叫 Mutation，通过在 store 中定义『命令』和执行器，要改变状态就通过 sotre 发出这个命令。Mutation 强调同步操作，至于你要对管理状态作出异步的操作就得看看 Action 如何异步修改状态?在组件中 vex 配置相关 action，然后该方法就直接在 vm 下可以访问，方法的实现通常是在异步操作中组合一些 mutation，当然，如果 Action 用在同步场景，你可以把 Actions 理解成用于组合 Mutation 的大 Mutation，另外，action 方法的第一个参数总是 store 简单同步操作用 Mutation 还是 Action？从语法来说，你喜欢哪个都行，不过统一开发思路，在组件内，只跟 action 打交道，然后action 里面再去转发 mutation，这样开发体验统一，你也无须访问 store，好维护。官方制定的规则也是只用 action。 怎么处理多模块？如果应用简单，mutation、action、state 各自定义一个总文件，如果多模块，那么在每个模块定义各自的 这三个部分，借助 vuex store 的 modules 配置，子模块内开发体验跟原来的没差，也不需要关注它是否为一个子模块。 我想要一些回调的钩子啥的，拦截一些state的处理作分析，有吗？store 有 middlewares 配置，让你可以拦截所有 mutation，在开发环境可以使用内置的 logger 中间件，打印 mutation ，而且能获得前后的 state 快照。 如果我不遵循潜规则，然后在vuex 以外修改状态，你管得着吗？确实管不着，不过开发阶段可以开启 strict 模式，在 mutation 以外地方修改 state 会报错。 我也想遵循潜规则，但是在表单 input 中用 v-model，双向绑定呀，会在 mutation 以外修改 state 呀，怎么办？提供三个思路： 不要用 v-model，改用 value 绑定显示，注册 input 事件，手动调用 action 更新 如果小 case，就不要让 veux 跟踪，弄个组件自己状态，继续愉快 v-model，vuex 管不到你的状态 保持 v-model，又让 vuex 管，那你定义一个 computed 的值，getter 你懂的，至于 setter 就调用 action 我怎么测试 mutation 和 action ?mutation 比较好测试，就是同步函数，当做工具方法测呗，自己模拟state开测。至于 action 呢，如果依赖了外部 api 会比较麻烦，借助 web pack 的 inject-loader 对每个依赖的外部方法手动 mock（包括请求的数据），是有点麻烦。 还有什么碉堡的要告诉我？mutation 和 action 支持热重载。用 vue 可以当上 CTO。 CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[{"name":"tech","slug":"tech","permalink":"http://zhenyong.site/categories/tech/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://zhenyong.site/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://zhenyong.site/tags/vuex/"}]},{"title":"如何跟踪仓库子目录之 subtree 命令","slug":"folk-git-folder","date":"2016-07-20T05:35:03.000Z","updated":"2016-07-20T17:18:20.000Z","comments":true,"path":"2016/07/20/folk-git-folder/","link":"","permalink":"http://zhenyong.site/2016/07/20/folk-git-folder/","excerpt":"想翻译 react 的网站，然后发现 github 仓库中，有关网站部分的源码放在子目录 /docs 下，于是想能否单独 folk 子目录 /docs，而且以后只 pull 这个子目录的更新，于是提交记录就只有该目录下的，我就能专心对比提交然后修改对应翻译。","text":"想翻译 react 的网站，然后发现 github 仓库中，有关网站部分的源码放在子目录 /docs 下，于是想能否单独 folk 子目录 /docs，而且以后只 pull 这个子目录的更新，于是提交记录就只有该目录下的，我就能专心对比提交然后修改对应翻译。 通过阅读下列资源 Forking a sub directory … part of my own repo Using Git subtrees to split a repository git-subtree/git-subtree.txt 找到一种奇葩解决方法，下面逐步讲解 假设 react 仓库长这样 12345react.git (master) |---/others |---/docs |-- a.txt |-- b.txt 我希望我的仓库长这样： 12345678my.git (master) |---/docs |-- a.txt |-- b.txt |---/docs-cn |-- a.txt |-- b.txt 其中 /docs 保持跟 react 的 /docs 内容一样，而 /docs-cn 则是我翻译新增的内容 步骤1. 准备我的仓库123git clone git@github.com:zhenyong/react-website-cn.gitcd react-website-cn 2. 拉取 react master 分支123git remote add react https://github.com/facebook/react.gitgit fetch react master:react-master 自动创建的本地 react-master 分支就相当于 react 库（master分支） 3. 分割子目录成新分支1234git checkout react-mastergit subtree split --prefix=docs -b react-docsgit checkout react-docsgit push origin react-docs 新的分支 react-docs 包含了 /docs 目录的所有内容，长这样 123my.git (react-docs) |-- a.txt |-- b.txt 4. 子目录指向 react-docs 分支12git checkout mastergit subtree add --prefix=docs --squash origin react-docs 在当前分支创建 app 目录，引用 origin react-docs 分支，可以理解成子目录作为一个子仓库，实际上 react-docs 的角色就是中转站 此时，我的 master 分支长这样 1234my.git (master) |---/docs |-- a.txt |-- b.txt 之后就可以在 master 增加翻译内容 5. 更新 react-docs当 react 内容有更新后，拉取 react 最新内容，重新分割 12345678git checkout react-mastergit pull react mastergit subtree split --prefix=docs --squash \\ --onto react-docs -b react-docs git checkout react-docs git push origin react-docs 注意 split 多了一个参数 –onto, 表明再次生成分支时基于原来 react-docs （HEAD）提交记录形成历史纪录 6. 我的 master 更新子仓库12git checkout mastergit subtree pull --prefix=docs --squash origin react-docs 总结通过 react 仓库分离子目录成为新的（中转）仓库，在我的仓库下建立子目录作为子仓库指向中转仓库，从而达到我的 /docs 目录跟踪 react 的\\docs 目录。 note: 为了演示命令，所以没有设置分支跟踪来简化命令。另外你也可以考虑先 clone react 仓库然后再操作。 CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[{"name":"tech","slug":"tech","permalink":"http://zhenyong.site/categories/tech/"}],"tags":[{"name":"git","slug":"git","permalink":"http://zhenyong.site/tags/git/"}]},{"title":"Flow in Vue","slug":"Flow-in-Vue","date":"2016-07-06T05:07:31.000Z","updated":"2016-09-29T11:08:27.000Z","comments":true,"path":"2016/07/06/Flow-in-Vue/","link":"","permalink":"http://zhenyong.site/2016/07/06/Flow-in-Vue/","excerpt":"Facebook 出品的 JS 静态类型检查器 JS 相关的静态检测，一般人都会想到 Typescript， 配合微软的 Code 编辑器，杠杠的，为何 vue 选用 Flow 呢，作者在知乎作了 回答 Flow 官网 Flow 官网（中文）","text":"Facebook 出品的 JS 静态类型检查器 JS 相关的静态检测，一般人都会想到 Typescript， 配合微软的 Code 编辑器，杠杠的，为何 vue 选用 Flow 呢，作者在知乎作了 回答 Flow 官网 Flow 官网（中文） Flow 简单体验安装mac 用户： 1brew install flow 然后命令行敲 flow，如果没有反应大概是 brew link 失败了，重新 link 一次就好了 linux 用户通过 npm 安装 flow-bin （全局方便点） windows 用户目前要使用非官方 build 的版本，这里 配置在项目根目录创建 .flowconfig 空白文件，让 flow 知道这个目录下的文件可以用 flow 检测，当然还可以通过这个文件配置一些规则 运行创建一个 hello.js，第一行 /* @flow */ 表明这个文件需要检测 1234567/* @flow */function foo(x) &#123; return x * 10;&#125;foo(&quot;Hello, world!&quot;) 在跟目录下，执行命令 1flow check 控制台输出 1234567: foo(&quot;Hello, world!&quot;) ^^^^^^^^^^^^^^^^^^^^ function call 4: return x * 10; ^ string. This type is incompatible with 4: return x * 10; ^^^^^^ number 这里检测到 foo 方法的参数 x 应该是数字类型，代码中使用了字符串 &quot;Hello, world!&quot; 作为参数就会报错 更多基本上 Typescript 你能用到的 Flow 都有，例如指定变量类型、函数返回值类型、自定义对象元类型… 参考 官方文档 编辑器实时检测通常都不会手动执行命令，结合编辑器实时监测，跟之前介绍的 eslint linter 差不多，sublime 安装 SublimeLinter 安装指南 SublimeLinter-flow安装指南 效果： Flow in Vue.flowconfig 配置文件1234567891011121314151617181920[ignore].*/node_modules/.*.*/test/.*.*/build/.*.*/examples/.*.*/benchmarks/.*[include][libs]flow[options]module.name_mapper=&apos;^compiler/\\(.*\\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/compiler/\\1&apos;module.name_mapper=&apos;^core/\\(.*\\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/core/\\1&apos;module.name_mapper=&apos;^shared/\\(.*\\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/shared/\\1&apos;module.name_mapper=&apos;^web/\\(.*\\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/platforms/web/\\1&apos;module.name_mapper=&apos;^server/\\(.*\\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/server/\\1&apos;module.name_mapper=&apos;^entries/\\(.*\\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/entries/\\1&apos;module.name_mapper=&apos;^sfc/\\(.*\\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/sfc/\\1&apos; 解释下各个配置意思 ignore：表示该以下匹配到的文件夹都不需要检测 include：这里是空白，默认所有文件，如果检测项目根目录以外就要罗列在这里 libs: 表示使用目录 /flow 下的接口定义文件 options: 第一行配置的效果是，当require(&#39;compiler/xx/yy&#39;) 时把加载路径重定向到 项目路径/src/compiler/xx/yy 接口类型文件回一下 Java 或者其它强类型 OO 语言，当你调用类中没定义的方法时，或者调用方法的参数个数不对时，IDE就会提醒，那么接口类型文件就有点这个意思，让你的类也有这么一个规则文件可以用来校验开发者的代码，举个例子： 12345678910// /flow/component.jsdeclare interface Component &#123; // constructor information static cid: number ...省略... $data: Object; $options: ComponentOptions;...省略... &#125; Component 是 vue 内部一个类，通过这个接口类型文件表明组件类有哪些成员，哪些静态属性等等，特别要看到 ComponentOptions，这对应到另一个接口类型。 通过这种接口类型，某种意义上，你就有了强类型 OO 语言写代码的一些优点。 当然 vue 的类型文件远不止这用到这点点，更多细节就不一一介绍 语法部分请参照Flow 官网或者我翻译的中文网站 至于 vue 为什么选用 flow 而不用相对流行的 TypeScript，参考他的知乎回答 Vue 2.0 为什么选用 Flow 进行静态代码检查而不是直接使用 TypeScript?。 而我个人也觉得 Flow 有些很实用的场景，例如你无需学习成本，就能用上他的智能检测，解决 null 相关的潜在问题。 CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[],"tags":[{"name":"flow","slug":"flow","permalink":"http://zhenyong.site/tags/flow/"}]},{"title":"ESLint in Vue","slug":"ESLint-in-Vue","date":"2016-07-05T04:02:35.000Z","updated":"2016-07-09T11:37:41.000Z","comments":true,"path":"2016/07/05/ESLint-in-Vue/","link":"","permalink":"http://zhenyong.site/2016/07/05/ESLint-in-Vue/","excerpt":"ESLint 一个 JavaScript 代码的静态检测工具","text":"ESLint 一个 JavaScript 代码的静态检测工具 相比之前比较流行的 JSHint，ESLint 扩展性强、配置灵活、支持 ES6 … ESLint 官网 ESLint 中文 参考官网安装 eslint 就可以在命令行检测 js 文件的语法错误 编辑器中使用 ESLint在实际开发中，更多是配合编辑器（Sublime Text）一起使用，在编写代码的时候使用 eslint 实时检测代码，并且提醒错误的部分，下面展示安装使用过程 1. 安装ESLint Node 模块1npm install -g eslint 2. 安装 Sublime Text 插件 SublimeLinter 安装指南 SublimeLinter-contrib-eslint 安装指南 SublimeLinter 是一个 代码检测基础框架，当需要具体检测方案则要安装对应的库，例如需要 eslint 监测则安装 SublimeLinter-contrib-eslint 3. 创建配置文件在项目根目录下创建 .eslintrc 文件 123456&#123; &quot;root&quot;: true, &quot;rules&quot;: &#123; &quot;eqeqeq&quot;: &quot;error&quot; &#125;&#125; 其中的 &quot;eqeqeq&quot;: &quot;warn&quot; 规则表明，如果代码中出现 == !=来比较则会出现错误提醒，建议使用 === !== 这个简单配置只是为了演示，具体参考 配置指南 配置指南（中文） 这样，写代码的时候就能实时检测错误并且提醒了： Vue 的 ESLint.eslintignore 文件123flowdistpackages 表明 eslint 检测时，要忽略掉这些目录 .eslintrc 文件12345678910&#123; &quot;root&quot;: true, &quot;parser&quot;: &quot;babel-eslint&quot;, &quot;extends&quot;: &quot;vue&quot;, &quot;plugins&quot;: [&quot;flow-vars&quot;], &quot;rules&quot;: &#123; &quot;flow-vars/define-flow-type&quot;: 1, &quot;flow-vars/use-flow-type&quot;: 1 &#125;&#125; 下面逐个配置解释： &quot;root&quot;: true 对于某个文件使用哪个配置文件，按照以下顺序查找 在待检测文件的同一目录查找配置文件 往上逐层父级目录查找，直到发现一个有 &quot;root&quot;: true 的 使用项目根目录配置文件 使用系统全局配置文件 &quot;parser&quot;: &quot;babel-eslint&quot; 使用非默认的 babel-eslint 作为代码解析器，同时你需要安装相应 node 模块 1npm install -save-dev babel-eslint 这样 eslint 就能识别 babel 语法的代码 &quot;extends&quot;: &quot;vue&quot; 官方或者第三方提供了一些配置模板，你只需继承则可以使用他们的模板配置，这里继承了 vue 意味着你需要安装 eslint-config-vue 这个 node 模块 1npm install -save-dev eslint-config-vue &quot;plugins&quot;: [&quot;flow-vars&quot;] 让 eslint 支持 Flow Script 的全局注解等语法，同时你也要安装对应的 node 模块 1npm install -save-dev eslint-plugin-flow-vars &quot;rules&quot;:{xx} 一些主要的配置都在 &quot;extends&quot;: &quot;vue&quot; 解决了，flow 插件部分的配置则在这里另外定义 总结使用 ESLint 保持团队编码风格统一，减少低级错误，真的很赞！ 另外推荐 airbnb 的 ES6 编码风格，它有配套的 eslint 模板，很赞 对于英文实在不行的，那就参考 ECMAScript6 编码规范–广发证券前端团队 CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[{"name":"tech","slug":"tech","permalink":"http://zhenyong.site/categories/tech/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://zhenyong.site/tags/vue/"}]},{"title":"Babel in Vue","slug":"Babel-in-Vue","date":"2016-07-04T02:36:26.000Z","updated":"2016-07-13T08:45:36.000Z","comments":true,"path":"2016/07/04/Babel-in-Vue/","link":"","permalink":"http://zhenyong.site/2016/07/04/Babel-in-Vue/","excerpt":"Babel 是一个 JavaScript 编译器 Vue 的所有模块代码都是用了 ES6 的语法，可是大多数浏览器对 ES6 支持不够，所以需要先把源码（ES6）转化为浏览器能够识别执行的代码（ES5），而这个过程就需要用到 Babel 这个工具","text":"Babel 是一个 JavaScript 编译器 Vue 的所有模块代码都是用了 ES6 的语法，可是大多数浏览器对 ES6 支持不够，所以需要先把源码（ES6）转化为浏览器能够识别执行的代码（ES5），而这个过程就需要用到 Babel 这个工具 简单例子对照 Babel 的 官网 首页的指南简单玩一下： 安装 安装 babel 命令行工具 （官网是在项目下安装，这里全局安装） 1npm install -g babel-cli 这样就能在命令行下启动 babel 另外，我们还要告诉 babel 使用哪种转码规则，这里使用 ES2015 preset。在项目下创建 .babelrc 文件 123&#123; \"presets\": [\"es2015\"]&#125; 然后还要安装对应转码规则包 1npm install --save-dev babel-preset-es2015 测试 创建 js 代码文件 test.js： 123456var hello = () =&gt; &#123; let name = 'peter' console.log('hello ' + name)&#125;hello() 转换： 1babel test.js --out-file test.compiled.js 生成 test.compiled.js 12345678&apos;use strict&apos;;var hello = function hello() &#123; var name = &apos;peter&apos;; console.log(&apos;hello &apos; + name);&#125;;hello(); 现在就可以在浏览器运行这段代码了 更多关于 babel 或者 es6 的知识可以参考官网，或者还有下面中文网站： InfoQ 专栏 - 深入浅出 ES6 阮一峰 - ECMAScript 6 入门 vue 中使用vue 中在构建代码的时候结合 webpack 和 babel 相关插件使用，。。。 //TODO 在 webpack 部分一起写 CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[{"name":"tech","slug":"tech","permalink":"http://zhenyong.site/categories/tech/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://zhenyong.site/tags/vue/"}]},{"title":"EditorConfig in Vue","slug":"EditorConfig-in-Vue","date":"2016-07-03T09:23:26.000Z","updated":"2016-07-05T07:14:16.000Z","comments":true,"path":"2016/07/03/EditorConfig-in-Vue/","link":"","permalink":"http://zhenyong.site/2016/07/03/EditorConfig-in-Vue/","excerpt":"EditorConfig 可以帮助开发者在不同的编辑器和IDE之间定义和维护一致的代码风格","text":"EditorConfig 可以帮助开发者在不同的编辑器和IDE之间定义和维护一致的代码风格 某些编辑器使用 EditorConfig 则需要安装对应的插件，Sublime Text 的话就安装 EditorConfig 源码中的配置文件 .editorconfig 123456789root = true[*]charset = utf-8indent_style = spaceindent_size = 2end_of_line = lfinsert_final_newline = truetrim_trailing_whitespace = true 解释一下这份配置的意思: root = true 当打开一个文件时，EditorConfig 插件在文件的目录和其每一级父目录查找 .editorconfig 文件，直到有一个配置文件包含 root = true EditorConfig 配置文件从上往下读取，并且路径最近的文件最后被读取，匹配到的配置按照读取顺序应用在代码上，最接近代码文件的属性优先级最高 [*]表示对所有文件文件使用 editorconfig，也可以指定某种文件格式 charset = utf-8 设置文件编码格式为 utf-8 indent_style = space 所有的缩进使用空格，包括 tab 键产生的空白 indent_size = 2 设置整数表示规定每级缩进的列数 end_of_line = lf 统一设置换行符，不同操作系统默认使用不同的换行符 windows 是 crlf，即 \\r\\n unix 则是 lf ，即 \\n insert_final_newline = true 文件都以一个空白行结尾 trim_trailing_whitespace = true 除去换行行首的任意空白字符 参考： 官网 EditorConfig介绍（译） CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[{"name":"tech","slug":"tech","permalink":"http://zhenyong.site/categories/tech/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://zhenyong.site/tags/vue/"}]},{"title":"Vue 源码工具链介绍","slug":"Vue-源码工具链介绍","date":"2016-07-03T08:55:15.000Z","updated":"2016-07-13T08:50:25.000Z","comments":true,"path":"2016/07/03/Vue-源码工具链介绍/","link":"","permalink":"http://zhenyong.site/2016/07/03/Vue-源码工具链介绍/","excerpt":"","text":"介绍 Vue 源码中使用到的工具，例如编辑器插件、打包工具、测试工具等等 有部分工具我平时也在用，为了系统地介绍，我也当做小白去学习 本人和小右平常使用的编辑器都是 Sublime Text 3 EditorConfig Babel ESLint Flow CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[{"name":"tech","slug":"tech","permalink":"http://zhenyong.site/categories/tech/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://zhenyong.site/tags/vue/"}]}]}