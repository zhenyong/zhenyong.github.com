{"meta":{"title":"Make Hungry","subtitle":"饥渴难耐","description":null,"author":"huáng zhèn yǒng","url":"http://zhenyong.site"},"pages":[{"title":"about","date":"2016-07-23T08:01:08.000Z","updated":"2016-07-23T08:01:08.000Z","comments":true,"path":"about/index.html","permalink":"http://zhenyong.site/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2016-07-23T08:08:53.000Z","updated":"2016-07-23T08:16:47.000Z","comments":false,"path":"categories/index.html","permalink":"http://zhenyong.site/categories/index.html","excerpt":"","text":""},{"title":"Docs","date":"2016-07-23T16:08:41.000Z","updated":"2016-07-23T16:08:41.000Z","comments":true,"path":"docs/index.html","permalink":"http://zhenyong.site/docs/index.html","excerpt":"","text":"React 中文文档Flow 中文文档"},{"title":"All tags","date":"2016-07-23T07:51:33.000Z","updated":"2016-07-23T07:54:51.000Z","comments":false,"path":"tags/index.html","permalink":"http://zhenyong.site/tags/index.html","excerpt":"","text":""},{"title":"","date":"2016-09-05T04:43:57.000Z","updated":"2016-09-05T04:43:57.000Z","comments":true,"path":"2016/09/01/resume/index.html","permalink":"http://zhenyong.site/2016/09/01/resume/index.html","excerpt":"","text":"var NexT = window.NexT || {}; var CONFIG = { scheme: 'Mist', sidebar: {\"position\":\"left\",\"display\":\"post\"}, fancybox: true, motion: true, duoshuo: { userId: 0, author: '博主' } }; resume | Make Hungry (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-81246715-1', 'auto'); ga('send', 'pageview'); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"//hm.baidu.com/hm.js?d90fc3ec35d1b7553506fdd9ba6b595a\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); (function() { var hm = document.createElement(\"script\"); hm.src = \"//tajs.qq.com/stats?sId=57582394\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); Make Hungry 饥渴难耐 首页 归档 标签 文档 搜索 (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){ (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t); e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st'); _st('install', 'yao6i6BKszfU6bZcj9su','2.0.0'); resume 发表于 2016-09-01 &nbsp; | &nbsp; 黃振涌 前端工程师 5年半 工作经验，2011年毕业于 深圳大学 • 信息与计算科学专业 手机：13510231096 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Email：116982086@qq.com &nbsp;&nbsp;&nbsp; 技术博客：zhenyong.site &nbsp;&nbsp;&nbsp;&nbsp; github账户：zhenyong 【工作经历】创业 2016.03 — 2016.08 (约半年)。。。 广发证券 2015.11 — 2016.03 (约4个月)互联网金融 技术 hack 『广发理财』 hybrid app 维护开发 『广发易淘金』 平台网站 维护开发 『微信预约开户』 webapp 开发 广发证券深圳研发团队是一群技术 hacker，追求前端全栈开发，使用技术也是极其激进。 2015.05 — 2015.10因膝盖手术，在家静养 用 angular、vue、nodejs 做一些外包项目 盒子支付 2013.12 — 2015.04 (约1年半)To C 软硬件 支付 C轮 &gt;500人 商户&amp;渠道 职位：前端技术leader（6人前端团队） 规范前后台开发流程 负责前端新人培训 负责第三方支付业务平台各系统的前端开发维护 负责O2O业务的移动商城 webapp 开发 Morningstar (SZ) 2010.10 — 2013.08 (约3年，包括实习)To B SasS 金融数据 报表分析 上市外企 &gt;2000人 职位：开发工程师 开发维护一套基于 jQuery 的 UI 库 与设计、产品沟通实现前后台交互 后台web层数据结构封装 【主要项目经验】第三方支付 业务 &amp; 运营 平台 @盒子支付 简介：使用者包括：公司总部、各级代理 和 商户。主要用于管理商户、员工、代理机构、POS设备、交易路由、交易模型、清算控制、系统公告… 整个大系统共有 19个子模块，150 个功能页面、涉及后台 310 个api，使用一年时间，高效地开发并逐步替换老系统。 技术情况：整体使用基于 backbone 的 marionette 框架，用OO风格编写 view 层，使用 requirejs 进行模块化加载，UI 组建大部分是基于 jQuery 的主流开源组件，主要组件 grid 使用 jqGrid 并对源码扩展。界面使用基于 bootstrap 的一套流行模板 ace，并用 sass 结合 compass 编写样式。使用 build 工具 gulp 对文件压缩打包等。 系统使用角色权限管理，前端将功能权限映射到各个 UI 资源实现前端的权限控制，所有模块间通讯使用事件。外观上使用了响应式设计，保证在移动端能使用。 流程实践：在一年多的开发实践过程，前端主导推动了前后端分离，为后台推荐 springmvc 的 web 层框架，便于后台实现纯服务的 restful api，使用 markdown 编写文档接口，遵循先文档后实现的原则。 移动商城 @盒子支付 简介：在一个native app 中混合一个 H5 的商城，店主用它管理销售商品，并分享到微信。 管理商品的功能是基于 angular 实现的，部分功能（例如 拍照、支付）需要native支持，所以在 H5 端使用统一的方法，然后根据平台不同再使用不同的通信方式。 而分享出去的商品页面则使用轻量级的 zepto 和 template 实现。 Direct/Office @Morningstar 简介：一整套企业级金融投资分析工具，是一个富客户端 web 软件。 我主要参与 资产组合 分析工具的开发，使用自家开发的一套基于 jQuery 的 UI Tookit 构建各个 widget，生成各种分析报表。在参与产品前两年开发中，积累了丰富的 js/html/css 开发经验，在后面一年里，产品线改用 Extjs 重新改写，这一年里我学习吸收了很多 Extjs 的源码，对 JS 在 OO 风格开发有了很深的认识。这期间我对前端产生了无比浓厚的兴趣，同时在业余时间关注学习 java web 后台方面的技术。 【技术栈】 Java Web — 大三开始自学 java，用 Servlet、SSH 开发过企业真实使用的系统，在实战过程熟悉基于 HTTP 的 Web 原理。 JS — 手敲超过6W 行 JS 代码，熟悉OO风格编码，曾熟读 mootools jQuery Extjs Vue.js源码，参与编写过一整套 UI 库。 HTML/CSS — 第一年工作每天手敲，并处理 IE6,7 的兼容，通读了一遍 W3C 相关规范，后期主要使用基于bootstrap 或 fundation 的模板。 Sass/Less/Stylus/autoprefix 等 css 后处理器 — 都在实际项目中用过，近期使用相对灵活的 stylus+nib。 Angular Vue Backbone — 有项目实战经验，近期集中研究 Vue 的最佳实践，跟进 React 发展，参与过 NG 2 的书籍编写。 Gulp Grunt Webpack Rollup Babel — 过去大量使用 gulp，编写过 gulp 插件，近期主要使用 webpack，并全面 ES6/npm 化。 HTTP 读过 1.1 最新的 RFC72xx 系列文档 其他关键字 — requirejs seajs express mongo sublime git jade android mocha karma phantomjs … …… 折腾前端各种流行 【自我描述】热爱学习、编程，享受把现实问题抽象设计成软件的过程，大三开始自学java技术，工作后投身前端开发，从此热爱这个行业。大学期间获学业类最高等奖学金，勤奋努力是身边人给我的评价。 在投身 IT 多年的工作中，经常思考如何提高生产效率，如何与别人愉快相处，并坚持每天两小时的业余学习。我的梦想是参与开发一个全世界都用上的软件。 加入盒子支付时，团队组建初期，面临人员缺少，总体技术水平不足的窘况，我充满信心地鼓励身边伙伴，促进大家技术交流，鼓舞身边每个人愉快热情地工作，让领导给了我标杆的评价。 我希望将来加盟的公司不是把技术人员当作完成项目产品的一个流程工具，希望在文化上是把工程师当作一个合作伙伴，为公司产品的茁壮成长尽情发挥能力，激发创新，伴随着企业日益壮大的同时，员工也能跟随成长，带着一份归属感，把企业发展作为自己的事业。 我热爱我的技术工作，无论过去如何，我依然对未来充满热情。 CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整 支持 & 鼓励 赏 微信打赏 支付宝打赏 开始折腾 Atom 分享到： 微博 QQ空间 腾讯微博 微信 文章目录 站点概览 huáng zhèn yǒng 9 日志 1 分类 9 标签 RSS github 1. 黃振涌1.1. 【工作经历】1.1.1. 创业 2016.03 — 2016.08 (约半年)1.1.2. 广发证券 2015.11 — 2016.03 (约4个月)1.1.3. 2015.05 — 2015.101.1.4. 盒子支付 2013.12 — 2015.04 (约1年半)1.1.5. Morningstar (SZ) 2010.10 — 2013.08 (约3年，包括实习)1.2. 【主要项目经验】1.2.1. 第三方支付 业务 & 运营 平台1.2.2. 移动商城1.2.3. Direct/Office1.3. 【技术栈】1.4. 【自我描述】 &copy; 2016 huáng zhèn yǒng 由 Hexo 强力驱动 主题 - NexT.Mist if (Object.prototype.toString.call(window.Promise) !== '[object Function]') { window.Promise = null; } var duoshuoQuery = {short_name:\"zhenyong\"}; (function() { var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.id = 'duoshuo-script'; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); })(); ___ **CC BY-NC-SA 3.0 CN** 本著作采用 [署名-非商业性使用-相同方式共享 3.0 中国大陆](https://creativecommons.org/licenses/by-nc-sa/3.0/cn/) 进行许可 欢迎转载，但转载请注明来自 [zhenyong.site](http://zhenyong.site)，并保持转载后文章内容的完整"}],"posts":[{"title":"开始折腾 Atom","slug":"starting-atom","date":"2016-08-03T05:05:49.000Z","updated":"2016-08-05T04:15:03.000Z","comments":true,"path":"2016/08/03/starting-atom/","link":"","permalink":"http://zhenyong.site/2016/08/03/starting-atom/","excerpt":"Atom 是 Github 出品，基于 Electron 开发的跨平台编辑器。 之前是 Sublime 重度使用者，因为 React Native 出了个只支持 Atom 的插件，于是开始折腾 Atom，以前没用是因为它太慢了，一个月卸三次装三次，目前 1.9 版本性能提升了好多，插件都是基于 JS，目前插件数量跟 Sublime 的差不多，毕竟是基于浏览器，使用的技术都是前端熟悉的。 那么，从更换主题开始吧…","text":"Atom 是 Github 出品，基于 Electron 开发的跨平台编辑器。 之前是 Sublime 重度使用者，因为 React Native 出了个只支持 Atom 的插件，于是开始折腾 Atom，以前没用是因为它太慢了，一个月卸三次装三次，目前 1.9 版本性能提升了好多，插件都是基于 JS，目前插件数量跟 Sublime 的差不多，毕竟是基于浏览器，使用的技术都是前端熟悉的。 那么，从更换主题开始吧… 更换主题下面是原来 Sublime 使用的界面主题和语法颜色，很高大上： 12&quot;theme&quot;: &quot;Material-Theme.sublime-theme&quot;,&quot;color_scheme&quot;: &quot;Packages/User/SublimeLinter/Oceanic Next (SL).tmTheme&quot; 在 Atom 中安装界面主题 material-ui 和语法颜色 oceanic-next，文档说的很详细 修改主题使用了上面的主题和颜色后，发现编辑区的背景颜色跟 sublime 用的不一样，因为 Atom 本质上是个 Chrome 浏览，第一个想法就是调出控制台 (alt+cmd+i)，查看这个节点 atom-text-editor 的样式 ，接着按照 material-ui 的文档修改主题： 1234567// styles/editor.lessatom-text-editor &#123; // 注释掉这行就好了 // background: @level-3-color; ...&#125; 如果擅长前端的童鞋用 Atom 上手会很高效，这玩意就是个浏览器，^_^ ！ 插件们 EditorConfig Atom 内置 whitespace 插件会『覆盖』掉 EditorConfig 配置，导致 trim_trailing_whitespace 和 insert_final_newline 在 .editorconfig 中无效，参考 github issue (##2016-08-03##) Markdown markdown-previwe 内置的 markdown-previwe 很好用，（shift+ctrl+m）打开实时预览，还能设置 github 的样式，很酷 markdown-scroll-sync 让预览视图随着编辑光标位置滚动，滚的很准！ Linter 错误提示的 UI 做的真好 linter-eslint linter-flow 如果安装了 nuclide 会引发配置错误提示，参考这里 问题不大，但是每次出现很烦，所以 Disable linter-flow，反正 nuclide 本身有 nuclide-flow 支持 Flow 检测 hyperclick 点击文本跳转的基础，支持各类扩展跳转，如安装 js-hyperclick 插件支持变量定义跳转等 js-hyperclick JS 点击变量跳转到定义处…强大到远超我想像 atom-ternjs 代码智能提示，还支持 ES6，它是会扫描代码作分析的，快赶上 IDE了。 highlight-selected 选中文本后，高亮其他相同文本，双击变量最实用 autocomplete-paths require、src 等路径提示 docblockr 愉快的写注释文档，包括方法等… regex-railroad-diagram 选中正则之后，展示可视化的匹配路径，酷~ file-icons 导航区文件图标，图标齐全好看 emmet 手写 HTML 的神器，有个快捷键会跟 markdown preview 冲突，参考这里 local-history 本地记录文件历史 pigments 颜色相关工具，包括：把rgb(x,x,x)背景色变成相应颜色，选色…牛 atom-beautify 代码格式化，支持巨多语言 auto-update-packages 自动更新插件，虽然设置里面点一下就可以，但是自动不更好吗 git-projects 快速打开本地 git 项目，省得切换一次命令行 minimap 像 Sublime 那样在右侧有个全景代码小图，支持很多扩展 language-babel 语法支持 ES6、JSX、Flow …，还支持预览 babel 或 react 编译结果 (nuclide)[https://atom.io/packages/nuclide] 帮助开发 ReactNative、Flow 相关项目，装完感觉更像 IDE nuclide 的 tree-view 覆盖原来的，所有原来 tree-view 上 git 状态颜色就看不到，参考这里，不用 nuclide 的 tree-view， 同时也失去它的 remote file sync 等功能 (open-recent)[https://atom.io/packages/open-recent] 像 Sublime 的 File -&gt; Open Recent，搞不懂为啥不内置 (react)[https://atom.io/packages/react] JSX 语法高亮、格式化…最喜欢的事 HTML-&gt;JSX (term3)[https://atom.io/packages/term3] 终端 (todo-show)[https://atom.io/packages/todo-show] 找出所有 // TODO (tool-bar)[https://atom.io/packages/tool-bar] 让 Atom 支持 toolbar，需要安装其他扩展插件 (Advanced Open File)[https://atom.io/packages/advanced-open-file] 快速打开硬盘上某个文件，如果不存在则创建，支持相对项目路径，创建多个文件，真方便 (keybinding-resolver)[https://atom.io/packages/keybinding-resolver] 查看快捷键对应哪些命令，命令冲突时最好用了 Git (git-plus)[https://atom.io/packages/git-plus] 便捷 git 操作 (merge-conflicts)[https://atom.io/packages/merge-conflicts] merge 冲突的时候，用上它方便逐个修改冲突 (source-preview)[https://atom.io/packages/source-preview] 转化后的代码预览，是一个基础插件，需要配合其他 provider 插件 疑难杂症 安装插件速度慢 在 ~/.atom/.apmrc 配置 npm 镜像 1registry = https://registry.npm.taobao.org 或者命令行 1apm config set registry https://registry.npm.taobao.org CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[],"tags":[{"name":"Atom","slug":"Atom","permalink":"http://zhenyong.site/tags/Atom/"}]},{"title":"Vuex 笔记之 Q & A","slug":"vuex-q-and-a","date":"2016-07-30T07:16:51.000Z","updated":"2016-07-30T07:43:20.000Z","comments":true,"path":"2016/07/30/vuex-q-and-a/","link":"","permalink":"http://zhenyong.site/2016/07/30/vuex-q-and-a/","excerpt":"Vuex 借鉴 Flux 开发思想，帮助你用更好的程序架构开发 Vue.js 应用，主要体现在帮你更好地管理状态。 通过『提问』和『回答』的方式记录 文档 笔记：","text":"Vuex 借鉴 Flux 开发思想，帮助你用更好的程序架构开发 Vue.js 应用，主要体现在帮你更好地管理状态。 通过『提问』和『回答』的方式记录 文档 笔记： 数据存储在哪里？整个应用的状态数据存储在一个单例 store 中 组件怎么获取状态？组件要使用状态（getter of state）则在组件引入 vuex 配置，为每个coputed 变量指定一个 getter 方法，方法的第一个参数总是 state，然后返回你要的 怎么修改状态？谨记组件的状态 getter 不要做任何直接修改状态的事情，或者是触发其他有副作用的事件等。想管理状态则触发 mutation，真正给 state 动刀的是在 vuex。每当你需要管理状态时，每个改变都可以定义成一个『命令』，叫 Mutation，通过在 store 中定义『命令』和执行器，要改变状态就通过 sotre 发出这个命令。Mutation 强调同步操作，至于你要对管理状态作出异步的操作就得看看 Action 如何异步修改状态?在组件中 vex 配置相关 action，然后该方法就直接在 vm 下可以访问，方法的实现通常是在异步操作中组合一些 mutation，当然，如果 Action 用在同步场景，你可以把 Actions 理解成用于组合 Mutation 的大 Mutation，另外，action 方法的第一个参数总是 store 简单同步操作用 Mutation 还是 Action？从语法来说，你喜欢哪个都行，不过统一开发思路，在组件内，只跟 action 打交道，然后action 里面再去转发 mutation，这样开发体验统一，你也无须访问 store，好维护。官方制定的规则也是只用 action。 怎么处理多模块？如果应用简单，mutation、action、state 各自定义一个总文件，如果多模块，那么在每个模块定义各自的 这三个部分，借助 vuex store 的 modules 配置，子模块内开发体验跟原来的没差，也不需要关注它是否为一个子模块。 我想要一些回调的钩子啥的，拦截一些state的处理作分析，有吗？store 有 middlewares 配置，让你可以拦截所有 mutation，在开发环境可以使用内置的 logger 中间件，打印 mutation ，而且能获得前后的 state 快照。 如果我不遵循潜规则，然后在vuex 以外修改状态，你管得着吗？确实管不着，不过开发阶段可以开启 strict 模式，在 mutation 以外地方修改 state 会报错。 我也想遵循潜规则，但是在表单 input 中用 v-model，双向绑定呀，会在 mutation 以外修改 state 呀，怎么办？提供三个思路： 不要用 v-model，改用 value 绑定显示，注册 input 事件，手动调用 action 更新 如果小 case，就不要让 veux 跟踪，弄个组件自己状态，继续愉快 v-model，vuex 管不到你的状态 保持 v-model，又让 vuex 管，那你定义一个 computed 的值，getter 你懂的，至于 setter 就调用 action 我怎么测试 mutation 和 action ?mutation 比较好测试，就是同步函数，当做工具方法测呗，自己模拟state开测。至于 action 呢，如果依赖了外部 api 会比较麻烦，借助 web pack 的 inject-loader 对每个依赖的外部方法手动 mock（包括请求的数据），是有点麻烦。 还有什么碉堡的要告诉我？mutation 和 action 支持热重载。用 vue 可以当上 CTO。 CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[{"name":"tech","slug":"tech","permalink":"http://zhenyong.site/categories/tech/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://zhenyong.site/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://zhenyong.site/tags/vuex/"}]},{"title":"如何跟踪仓库子目录之 subtree 命令","slug":"folk-git-folder","date":"2016-07-20T05:35:03.000Z","updated":"2016-07-20T17:18:20.000Z","comments":true,"path":"2016/07/20/folk-git-folder/","link":"","permalink":"http://zhenyong.site/2016/07/20/folk-git-folder/","excerpt":"想翻译 react 的网站，然后发现 github 仓库中，有关网站部分的源码放在子目录 /docs 下，于是想能否单独 folk 子目录 /docs，而且以后只 pull 这个子目录的更新，于是提交记录就只有该目录下的，我就能专心对比提交然后修改对应翻译。","text":"想翻译 react 的网站，然后发现 github 仓库中，有关网站部分的源码放在子目录 /docs 下，于是想能否单独 folk 子目录 /docs，而且以后只 pull 这个子目录的更新，于是提交记录就只有该目录下的，我就能专心对比提交然后修改对应翻译。 通过阅读下列资源 Forking a sub directory … part of my own repo Using Git subtrees to split a repository git-subtree/git-subtree.txt 找到一种奇葩解决方法，下面逐步讲解 假设 react 仓库长这样 12345react.git (master) |---/others |---/docs |-- a.txt |-- b.txt 我希望我的仓库长这样： 12345678my.git (master) |---/docs |-- a.txt |-- b.txt |---/docs-cn |-- a.txt |-- b.txt 其中 /docs 保持跟 react 的 /docs 内容一样，而 /docs-cn 则是我翻译新增的内容 步骤1. 准备我的仓库123git clone git@github.com:zhenyong/react-website-cn.gitcd react-website-cn 2. 拉取 react master 分支123git remote add react https://github.com/facebook/react.gitgit fetch react master:react-master 自动创建的本地 react-master 分支就相当于 react 库（master分支） 3. 分割子目录成新分支1234git checkout react-mastergit subtree split --prefix=docs -b react-docsgit checkout react-docsgit push origin react-docs 新的分支 react-docs 包含了 /docs 目录的所有内容，长这样 123my.git (react-docs) |-- a.txt |-- b.txt 4. 子目录指向 react-docs 分支12git checkout mastergit subtree add --prefix=docs --squash origin react-docs 在当前分支创建 app 目录，引用 origin react-docs 分支，可以理解成子目录作为一个子仓库，实际上 react-docs 的角色就是中转站 此时，我的 master 分支长这样 1234my.git (master) |---/docs |-- a.txt |-- b.txt 之后就可以在 master 增加翻译内容 5. 更新 react-docs当 react 内容有更新后，拉取 react 最新内容，重新分割 12345678git checkout react-mastergit pull react mastergit subtree split --prefix=docs --squash \\ --onto react-docs -b react-docs git checkout react-docs git push origin react-docs 注意 split 多了一个参数 –onto, 表明再次生成分支时基于原来 react-docs （HEAD）提交记录形成历史纪录 6. 我的 master 更新子仓库12git checkout mastergit subtree pull --prefix=docs --squash origin react-docs 总结通过 react 仓库分离子目录成为新的（中转）仓库，在我的仓库下建立子目录作为子仓库指向中转仓库，从而达到我的 /docs 目录跟踪 react 的\\docs 目录。 note: 为了演示命令，所以没有设置分支跟踪来简化命令。另外你也可以考虑先 clone react 仓库然后再操作。 CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[{"name":"tech","slug":"tech","permalink":"http://zhenyong.site/categories/tech/"}],"tags":[{"name":"git","slug":"git","permalink":"http://zhenyong.site/tags/git/"}]},{"title":"Flow in Vue","slug":"Flow-in-Vue","date":"2016-07-06T05:07:31.000Z","updated":"2016-08-02T17:41:31.000Z","comments":true,"path":"2016/07/06/Flow-in-Vue/","link":"","permalink":"http://zhenyong.site/2016/07/06/Flow-in-Vue/","excerpt":"Facebook 出品的 JS 静态类型检查器 JS 相关的静态检测，一般人都会想到 Typescript， 配合微软的 Code 编辑器，杠杠的，为何 vue 选用 Flow 呢，作者在知乎作了 回答 Flow 官网 Flow 官网（中文）","text":"Facebook 出品的 JS 静态类型检查器 JS 相关的静态检测，一般人都会想到 Typescript， 配合微软的 Code 编辑器，杠杠的，为何 vue 选用 Flow 呢，作者在知乎作了 回答 Flow 官网 Flow 官网（中文） Flow 简单体验安装mac 用户： 1brew install flow 然后命令行敲 flow，如果没有反应大概是 brew link 失败了，重新 link 一次就好了 linux 用户通过 npm 安装 flow-bin （全局方便点） windows 用户目前要使用非官方 build 的版本，这里 配置在项目根目录创建 .flowconfig 空白文件，让 flow 知道这个目录下的文件可以用 flow 检测，当然还可以通过这个文件配置一些规则 运行创建一个 hello.js，第一行 /* @flow */ 表明这个文件需要检测 1234567/* @flow */function foo(x) &#123; return x * 10;&#125;foo(&quot;Hello, world!&quot;) 在跟目录下，执行命令 1flow check 控制台输出 1234567: foo(&quot;Hello, world!&quot;) ^^^^^^^^^^^^^^^^^^^^ function call 4: return x * 10; ^ string. This type is incompatible with 4: return x * 10; ^^^^^^ number 这里检测到 foo 方法的参数 x 应该是数字类型，代码中使用了字符串 &quot;Hello, world!&quot; 作为参数就会报错 更多基本上 Typescript 你能用到的 Flow 都有，例如指定变量类型、函数返回值类型、自定义对象元类型… 参考 官方文档 编辑器实时检测通常都不会手动执行命令，结合编辑器实时监测，跟之前介绍的 eslint linter 差不多，sublime 安装 SublimeLinter 安装指南 SublimeLinter-flow安装指南 效果： Flow in Vue.flowconfig 配置文件1234567891011121314151617181920[ignore].*/node_modules/.*.*/test/.*.*/build/.*.*/examples/.*.*/benchmarks/.*[include][libs]flow[options]module.name_mapper=&apos;^compiler/\\(.*\\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/compiler/\\1&apos;module.name_mapper=&apos;^core/\\(.*\\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/core/\\1&apos;module.name_mapper=&apos;^shared/\\(.*\\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/shared/\\1&apos;module.name_mapper=&apos;^web/\\(.*\\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/platforms/web/\\1&apos;module.name_mapper=&apos;^server/\\(.*\\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/server/\\1&apos;module.name_mapper=&apos;^entries/\\(.*\\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/entries/\\1&apos;module.name_mapper=&apos;^sfc/\\(.*\\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/sfc/\\1&apos; 解释下各个配置意思 ignore：表示该以下匹配到的文件夹都不需要检测 include：这里是空白，默认所有文件，如果检测项目根目录以外就要罗列在这里 libs: 表示使用目录 /flow 下的接口定义文件 options: 第一行配置的效果是，当require(&#39;compiler/xx/yy&#39;) 时把加载路径重定向到 项目路径/src/compiler/xx/yy 接口类型文件回一下 Java 或者其它强类型 OO 语言，当你调用类中没定义的方法时，或者调用方法的参数个数不对时，IDE就会提醒，那么接口类型文件就有点这个意思，让你的类也有这么一个规则文件可以用来校验开发者的代码，举个例子： 12345678910// /flow/component.jsdeclare interface Component &#123; // constructor information static cid: number ...省略... $data: Object; $options: ComponentOptions;...省略... &#125; Component 是 vue 内部一个类，通过这个接口类型文件表明组件类有哪些成员，哪些静态属性等等，特别要看到 ComponentOptions，这对应到另一个接口类型。 通过这种接口类型，某种意义上，你就有了强类型 OO 语言写代码的一些优点。 当然 vue 的类型文件远不止这用到这点点，更多细节就不一一介绍 语法部分请参照Flow 官网或者我翻译的中文网站 至于 vue 为什么选用 flow 而不用相对流行的 TypeScript，参考他的知乎回答 Vue 2.0 为什么选用 Flow 进行静态代码检查而不是直接使用 TypeScript?。 而我个人也觉得 Flow 有些很实用的场景，例如你无需学习成本，就能用上他的智能检测，解决 null 相关的潜在问题。 CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[],"tags":[{"name":"flow","slug":"flow","permalink":"http://zhenyong.site/tags/flow/"}]},{"title":"ESLint in Vue","slug":"ESLint-in-Vue","date":"2016-07-05T04:02:35.000Z","updated":"2016-07-09T11:37:41.000Z","comments":true,"path":"2016/07/05/ESLint-in-Vue/","link":"","permalink":"http://zhenyong.site/2016/07/05/ESLint-in-Vue/","excerpt":"ESLint 一个 JavaScript 代码的静态检测工具","text":"ESLint 一个 JavaScript 代码的静态检测工具 相比之前比较流行的 JSHint，ESLint 扩展性强、配置灵活、支持 ES6 … ESLint 官网 ESLint 中文 参考官网安装 eslint 就可以在命令行检测 js 文件的语法错误 编辑器中使用 ESLint在实际开发中，更多是配合编辑器（Sublime Text）一起使用，在编写代码的时候使用 eslint 实时检测代码，并且提醒错误的部分，下面展示安装使用过程 1. 安装ESLint Node 模块1npm install -g eslint 2. 安装 Sublime Text 插件 SublimeLinter 安装指南 SublimeLinter-contrib-eslint 安装指南 SublimeLinter 是一个 代码检测基础框架，当需要具体检测方案则要安装对应的库，例如需要 eslint 监测则安装 SublimeLinter-contrib-eslint 3. 创建配置文件在项目根目录下创建 .eslintrc 文件 123456&#123; &quot;root&quot;: true, &quot;rules&quot;: &#123; &quot;eqeqeq&quot;: &quot;error&quot; &#125;&#125; 其中的 &quot;eqeqeq&quot;: &quot;warn&quot; 规则表明，如果代码中出现 == !=来比较则会出现错误提醒，建议使用 === !== 这个简单配置只是为了演示，具体参考 配置指南 配置指南（中文） 这样，写代码的时候就能实时检测错误并且提醒了： Vue 的 ESLint.eslintignore 文件123flowdistpackages 表明 eslint 检测时，要忽略掉这些目录 .eslintrc 文件12345678910&#123; &quot;root&quot;: true, &quot;parser&quot;: &quot;babel-eslint&quot;, &quot;extends&quot;: &quot;vue&quot;, &quot;plugins&quot;: [&quot;flow-vars&quot;], &quot;rules&quot;: &#123; &quot;flow-vars/define-flow-type&quot;: 1, &quot;flow-vars/use-flow-type&quot;: 1 &#125;&#125; 下面逐个配置解释： &quot;root&quot;: true 对于某个文件使用哪个配置文件，按照以下顺序查找 在待检测文件的同一目录查找配置文件 往上逐层父级目录查找，直到发现一个有 &quot;root&quot;: true 的 使用项目根目录配置文件 使用系统全局配置文件 &quot;parser&quot;: &quot;babel-eslint&quot; 使用非默认的 babel-eslint 作为代码解析器，同时你需要安装相应 node 模块 1npm install -save-dev babel-eslint 这样 eslint 就能识别 babel 语法的代码 &quot;extends&quot;: &quot;vue&quot; 官方或者第三方提供了一些配置模板，你只需继承则可以使用他们的模板配置，这里继承了 vue 意味着你需要安装 eslint-config-vue 这个 node 模块 1npm install -save-dev eslint-config-vue &quot;plugins&quot;: [&quot;flow-vars&quot;] 让 eslint 支持 Flow Script 的全局注解等语法，同时你也要安装对应的 node 模块 1npm install -save-dev eslint-plugin-flow-vars &quot;rules&quot;:{xx} 一些主要的配置都在 &quot;extends&quot;: &quot;vue&quot; 解决了，flow 插件部分的配置则在这里另外定义 总结使用 ESLint 保持团队编码风格统一，减少低级错误，真的很赞！ 另外推荐 airbnb 的 ES6 编码风格，它有配套的 eslint 模板，很赞 对于英文实在不行的，那就参考 ECMAScript6 编码规范–广发证券前端团队 CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[{"name":"tech","slug":"tech","permalink":"http://zhenyong.site/categories/tech/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://zhenyong.site/tags/vue/"}]},{"title":"Babel in Vue","slug":"Babel-in-Vue","date":"2016-07-04T02:36:26.000Z","updated":"2016-07-13T08:45:36.000Z","comments":true,"path":"2016/07/04/Babel-in-Vue/","link":"","permalink":"http://zhenyong.site/2016/07/04/Babel-in-Vue/","excerpt":"Babel 是一个 JavaScript 编译器 Vue 的所有模块代码都是用了 ES6 的语法，可是大多数浏览器对 ES6 支持不够，所以需要先把源码（ES6）转化为浏览器能够识别执行的代码（ES5），而这个过程就需要用到 Babel 这个工具","text":"Babel 是一个 JavaScript 编译器 Vue 的所有模块代码都是用了 ES6 的语法，可是大多数浏览器对 ES6 支持不够，所以需要先把源码（ES6）转化为浏览器能够识别执行的代码（ES5），而这个过程就需要用到 Babel 这个工具 简单例子对照 Babel 的 官网 首页的指南简单玩一下： 安装 安装 babel 命令行工具 （官网是在项目下安装，这里全局安装） 1npm install -g babel-cli 这样就能在命令行下启动 babel 另外，我们还要告诉 babel 使用哪种转码规则，这里使用 ES2015 preset。在项目下创建 .babelrc 文件 123&#123; \"presets\": [\"es2015\"]&#125; 然后还要安装对应转码规则包 1npm install --save-dev babel-preset-es2015 测试 创建 js 代码文件 test.js： 123456var hello = () =&gt; &#123; let name = 'peter' console.log('hello ' + name)&#125;hello() 转换： 1babel test.js --out-file test.compiled.js 生成 test.compiled.js 12345678&apos;use strict&apos;;var hello = function hello() &#123; var name = &apos;peter&apos;; console.log(&apos;hello &apos; + name);&#125;;hello(); 现在就可以在浏览器运行这段代码了 更多关于 babel 或者 es6 的知识可以参考官网，或者还有下面中文网站： InfoQ 专栏 - 深入浅出 ES6 阮一峰 - ECMAScript 6 入门 vue 中使用vue 中在构建代码的时候结合 webpack 和 babel 相关插件使用，。。。 //TODO 在 webpack 部分一起写 CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[{"name":"tech","slug":"tech","permalink":"http://zhenyong.site/categories/tech/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://zhenyong.site/tags/vue/"}]},{"title":"EditorConfig in Vue","slug":"EditorConfig-in-Vue","date":"2016-07-03T09:23:26.000Z","updated":"2016-07-05T07:14:16.000Z","comments":true,"path":"2016/07/03/EditorConfig-in-Vue/","link":"","permalink":"http://zhenyong.site/2016/07/03/EditorConfig-in-Vue/","excerpt":"EditorConfig 可以帮助开发者在不同的编辑器和IDE之间定义和维护一致的代码风格","text":"EditorConfig 可以帮助开发者在不同的编辑器和IDE之间定义和维护一致的代码风格 某些编辑器使用 EditorConfig 则需要安装对应的插件，Sublime Text 的话就安装 EditorConfig 源码中的配置文件 .editorconfig 123456789root = true[*]charset = utf-8indent_style = spaceindent_size = 2end_of_line = lfinsert_final_newline = truetrim_trailing_whitespace = true 解释一下这份配置的意思: root = true 当打开一个文件时，EditorConfig 插件在文件的目录和其每一级父目录查找 .editorconfig 文件，直到有一个配置文件包含 root = true EditorConfig 配置文件从上往下读取，并且路径最近的文件最后被读取，匹配到的配置按照读取顺序应用在代码上，最接近代码文件的属性优先级最高 [*]表示对所有文件文件使用 editorconfig，也可以指定某种文件格式 charset = utf-8 设置文件编码格式为 utf-8 indent_style = space 所有的缩进使用空格，包括 tab 键产生的空白 indent_size = 2 设置整数表示规定每级缩进的列数 end_of_line = lf 统一设置换行符，不同操作系统默认使用不同的换行符 windows 是 crlf，即 \\r\\n unix 则是 lf ，即 \\n insert_final_newline = true 文件都以一个空白行结尾 trim_trailing_whitespace = true 除去换行行首的任意空白字符 参考： 官网 EditorConfig介绍（译） CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[{"name":"tech","slug":"tech","permalink":"http://zhenyong.site/categories/tech/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://zhenyong.site/tags/vue/"}]},{"title":"Vue 源码工具链介绍","slug":"Vue-源码工具链介绍","date":"2016-07-03T08:55:15.000Z","updated":"2016-07-13T08:50:25.000Z","comments":true,"path":"2016/07/03/Vue-源码工具链介绍/","link":"","permalink":"http://zhenyong.site/2016/07/03/Vue-源码工具链介绍/","excerpt":"","text":"介绍 Vue 源码中使用到的工具，例如编辑器插件、打包工具、测试工具等等 有部分工具我平时也在用，为了系统地介绍，我也当做小白去学习 本人和小右平常使用的编辑器都是 Sublime Text 3 EditorConfig Babel ESLint Flow CC BY-NC-SA 3.0 CN 本著作采用 署名-非商业性使用-相同方式共享 3.0 中国大陆 进行许可 欢迎转载，但转载请注明来自 zhenyong.site，并保持转载后文章内容的完整","categories":[{"name":"tech","slug":"tech","permalink":"http://zhenyong.site/categories/tech/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://zhenyong.site/tags/vue/"}]}]}