<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Make Hungry</title>
  <subtitle>饥渴难耐</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhenyong.site/"/>
  <updated>2016-10-28T07:29:19.000Z</updated>
  <id>http://zhenyong.site/</id>
  
  <author>
    <name>huáng zhèn yǒng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你用 webpack 1.x 输出的 hash 靠谱不？</title>
    <link href="http://zhenyong.site/2016/10/27/webpack-long-term-hash/"/>
    <id>http://zhenyong.site/2016/10/27/webpack-long-term-hash/</id>
    <published>2016-10-27T11:05:08.000Z</published>
    <updated>2016-10-28T07:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>使用 webpack 构建输出文件时，通常会给文件名加上 hash，该 hash 值根据文件内容计算得到，只要文件内容不变，hash 就不变，于是就可以利用浏览器缓存来节省下载流量。可是 webpack 提供的 hash 似乎不那么靠谱…</p>
</blockquote>
<a id="more"></a>
<p>本文只围绕如何保证 webpack 1.x 在 <strong>生产发布阶段</strong> 输出稳定的 hash 值展开讨论，如果对 webpack 还没了解的，可以戳 <a href="http://webpack.github.io/docs/" target="_blank" rel="external">webpack</a>。</p>
<p>本文 基于 webpack 1.x 的背景展开讨论，毕竟有些问题在 webpack 2 已经得到解决。为了方便描述问题，文中展示的代码、配置可能很挫，也许不是工程最佳实践，请轻拍。</p>
<p>懒得看文章的可以考虑直接读插件源码 <a href="https://github.com/zhenyong/webpack-stable-module-id-and-hash" target="_blank" rel="external">zhenyong/webpack-stable-module-id-and-hash</a></p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>除了 html 文件以外，其他静态资源文件名都带上哈希值，根据文件本身的内容计算得到，保证文件没变化，则构建后的文件名跟上次一样。</p>
<h2 id="webpack-提供的-hash"><a href="#webpack-提供的-hash" class="headerlink" title="webpack 提供的 hash"></a>webpack 提供的 hash</h2><h3 id="hash"><a href="#hash" class="headerlink" title="[hash]"></a>[hash]</h3><p>假设<strong>文件目录</strong>长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/src</div><div class="line">  |- pageA.js (入口1)</div><div class="line">  |- pageB.js (入口2)</div></pre></td></tr></table></figure>
<p>使用 <strong>webpack 配置</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">entry: &#123;</div><div class="line">    pageA: <span class="string">'./src/pageA.js'</span>,</div><div class="line">    pageB: <span class="string">'./src/pageB.js'</span>,</div><div class="line">&#125;,</div><div class="line">output: &#123;</div><div class="line">    path: __dirname + <span class="string">'/build'</span>,</div><div class="line">    <span class="comment">// [hash:4] 表示截取 [hash] 前四位</span></div><div class="line">    filename: <span class="string">'[name].[hash:4].js'</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p><strong>首次</strong>构建输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pageA.c56c.js  1.47 kB       0  [emitted]  pageA</div><div class="line">pageB.c56c.js  1.47 kB       1  [emitted]  pageB</div></pre></td></tr></table></figure>
<p><strong>再次</strong>构建输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pageA.c56c.js  1.47 kB       0  [emitted]  pageA</div><div class="line">pageB.c56c.js  1.47 kB       1  [emitted]  pageB</div></pre></td></tr></table></figure></p>
<p>hash 值是稳定的呀，是不是就可以了呢？且慢！</p>
<p>根据 <a href="https://github.com/webpack/docs/wiki/Configuration#outputfilename" target="_blank" rel="external">Configuration · webpack/docs Wiki</a> ：</p>
<blockquote>
<p>[hash] is replaced by the hash of the compilation.</p>
</blockquote>
<p>意译：</p>
<blockquote>
<p>[hash] 是根据一个 compilation 对象计算得出的哈希值，如果 compilation 对象的信息不变，则 [hash] 不变</p>
</blockquote>
<p>结合 <a href="http://webpack.github.io/docs/how-to-write-a-plugin.html#compiler-and-compilation" target="_blank" rel="external">how to write a plugin</a> 提到：</p>
<blockquote>
<p>A <code>compilation</code> object represents a single build of versioned assets. While running Webpack development middleware, a new compilation will be created each time a file change is detected, thus generating a new set of compiled assets. A compilation surfaces information about the present state of module resources, compiled assets, changed files, and watched dependencies.</p>
</blockquote>
<p>意译：</p>
<blockquote>
<p><code>compilation</code> 对象代表对某个版本进行一次编译构建的过程，如果在开发模式下（例如用 –watch 检测变化，实时编译），则每次内容变化时会新建一个 complidation，包含了构建所需的上下文信息（构建器配置、文件、文件依赖）。</p>
</blockquote>
<p>我们来动一下 <code>pageA.js</code>，再次构建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pageA.e6a9.js  1.48 kB       0  [emitted]  pageA</div><div class="line">pageB.e6a9.js  1.47 kB       1  [emitted]  pageB</div></pre></td></tr></table></figure>
<p>发现 hash 变了，并且所有文件的 hash 值总是一样，这似乎就跟文档描述的一致，只要构建过程依赖的任何资源（代码）发生变化，<code>compilation</code> 的信息就会跟上一次不一样了。</p>
<p>那是不是肯定说，源码不变的话，hash 值就一定稳定呢？也不是的，我们改一下 webpack 配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">entry: &#123;</div><div class="line">    pageA: <span class="string">'./src/pageA.js'</span>,</div><div class="line">    <span class="comment">// 不再构建入口 pageB</span></div><div class="line">    <span class="comment">// pageB: './src/pageB.js',</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>再次构建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pageA.1f01.js  1.48 kB       0  [emitted]  pageA</div></pre></td></tr></table></figure></p>
<p><code>compilation</code> 的信息还包括构建上下文，所以，移除入口或者换个loader 都会引起 hash 改变。</p>
<p><code>[hash]</code> 的缺点很明显，不是根据内容来计算哈希，但是 hash 值是”稳定的”，用这种方案能保证『每次上线，浏览器访问到的静态资源都是新的（url 变了）』</p>
<p>你接受用 <code>[hash]</code> 吗，我是接受不了？于是我们看 webpack 提供的另一种根据内容计算 hash 的配置。</p>
<h3 id="chunkhash"><a href="#chunkhash" class="headerlink" title="[chunkhash]"></a>[chunkhash]</h3><blockquote>
<p>[chunkhash] is replaced by the hash of the chunk.</p>
</blockquote>
<p>意译：</p>
<blockquote>
<p>[chunkhash] 根据 chunk 的内容计算得到。（chunk 可以理解成一个输出文件，其中可能包含多个 js 模块）</p>
</blockquote>
<p>我们改下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">entry: &#123;</div><div class="line">    pageA: &apos;./src/pageA.js&apos;,</div><div class="line">    pageB: &apos;./src/pageB.js&apos;,</div><div class="line">&#125;,</div><div class="line">output: &#123;</div><div class="line">    path: __dirname + &apos;/build&apos;,</div><div class="line">    filename: &apos;[name].[chunkhash:4].js&apos;,</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>构建试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pageA.f308.js  1.48 kB       0  [emitted]  pageA</div><div class="line">pageB.53a9.js  1.47 kB       1  [emitted]  pageB</div></pre></td></tr></table></figure>
<p>动下 <code>pageA.js</code> 再构建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pageA.16d6.js  1.48 kB       0  [emitted]  pageA</div><div class="line">pageB.53a9.js  1.47 kB       1  [emitted]  pageB</div></pre></td></tr></table></figure>
<p>发现只有 pageA 的 hash 变了，似乎 [chunkhash] 就能解决问题了？且慢！</p>
<p>我们目前的代码没涉及到 css，先加点 css 文件依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/src</div><div class="line">  |- pageA.js</div><div class="line">  |- pageA.css</div><div class="line"></div><div class="line">//pageA.js</div><div class="line">require(&apos;./a.css&apos;);</div></pre></td></tr></table></figure>
<p>给 webpack 配置 css 文件的 loader，并且抽取所有样式输出到一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">module: &#123;</div><div class="line">    loaders: [&#123;</div><div class="line">        test: /\.css$/,</div><div class="line">        loader: ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader&apos;)</div><div class="line">    &#125;],</div><div class="line">&#125;,</div><div class="line">plugins: [</div><div class="line">    // 这里的 contenthash 是 ExtractTextPlugin 根据抽取输出的文件内容计算得到</div><div class="line">    new ExtractTextPlugin(&apos;[name].[contenthash:4].css&apos;)</div><div class="line">],</div></pre></td></tr></table></figure></p>
<p>构建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pageA.ab4b.js    1.6 kB       0  [emitted]  pageA</div><div class="line">pageA.b9bc.css  36 bytes       0  [emitted]  pageA</div></pre></td></tr></table></figure>
<p>改一下样式，那么样式的 hash 肯定会变的，那 pageA.js 的 hash 变不变呢?</p>
<p>答案是『变了』：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pageA.0482.js    1.6 kB       0  [emitted]  pageA</div><div class="line">pageA.c61a.css  31 bytes       0  [emitted]  pageA</div></pre></td></tr></table></figure>
<p>记得之前说 webpack 的 <code>[chunkhash]</code> 是根据 chunk 的内容计算的，而 pageA.js 这个 chunk 的输出在 webpack 看来是包括 css 文件的，只不过被你抽取出来罢了，所以你改 css 也就改了这个 chunk 的内容，这体验很不好吧，怎么让 css 不影响 js 的 hash 呢？</p>
<h2 id="自定义-chunkhash"><a href="#自定义-chunkhash" class="headerlink" title="自定义 chunkhash"></a>自定义 chunkhash</h2><p>源码 <a href="https://github.com/webpack/webpack/blob/75caa169bcf63c66ab069c38c73c3ab0e873cdc2/lib/Compilation.js#L915,L928" target="_blank" rel="external">webpack/Compilation.js</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">this.applyPlugins(&quot;chunk-hash&quot;, chunk, chunkHash);</div><div class="line">chunk.hash = chunkHash.digest(hashDigest);</div><div class="line">...</div></pre></td></tr></table></figure>
<p>通过这段代码可以发现，通过在 ‘chunk-hash’ “钩子” 中替换掉 chunk 的 digest 方法，就可以自定义 <code>chunk.hash</code> 了。</p>
<p>查看文档 <a href="http://webpack.github.io/docs/how-to-write-a-plugin.html#accessing-the-compilation" target="_blank" rel="external">how to write a plugin</a> 了解怎么写插件来注册一个钩子方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">plugins: [</div><div class="line">        ...</div><div class="line">        new ContentHashPlugin() <span class="comment">// 添加插件（生产发布阶段使用）</span></div><div class="line">    ],</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 插件函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ContentHashPlugin</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="comment">// webpack 会执行插件函数的 apply 方法</span></div><div class="line">ContentHashPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</div><div class="line">    compiler.plugin(<span class="string">'compilation'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">compilation</span>) </span>&#123;</div><div class="line">        compilation.plugin(<span class="string">'chunk-hash'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk, chunkHash</span>) </span>&#123;</div><div class="line">            <span class="comment">// 这里注册了之前说到的 'chunk-hash' 钩子</span></div><div class="line">            chunk.digest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            	<span class="keyword">return</span> <span class="string">'这就是自定义的 hash 值'</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>那么这个 hash 值如何计算好呢？</p>
<p>可以将 chunk 所依赖的各个模块 (单个源码文件) 的内容拼接后计算一个 md5 作为 hash 值，当然需要对所有文件排序后再拼接：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> md5Cache = &#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">md5</span>(<span class="params">content</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!md5Cache[content]) &#123;</div><div class="line">        md5Cache[content] = crypto.createHash(<span class="string">'md5'</span>) <span class="comment">//</span></div><div class="line">            .update(content, <span class="string">'utf-8'</span>).digest(<span class="string">'hex'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> md5Cache[content];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ContentHashPlugin</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">ContentHashPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> context = compiler.options.context;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getModFilePath</span>(<span class="params">mod</span>) </span>&#123;</div><div class="line">    	<span class="comment">// 获取形如 './src/pageA.css' 这样的路径</span></div><div class="line">    	<span class="comment">// libIdent 方法会处理好不同平台的路径分隔符问题</span></div><div class="line">        <span class="keyword">return</span> mod.libIdent(&#123;</div><div class="line">            context: context</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">// 根据模块对应的文件路径排序</span></div><div class="line">	<span class="comment">//（可以根据模块ID，但是暂时不靠谱，后面会讲）</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">compareMod</span>(<span class="params">modA, modB</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> modAPath = getModFilePath(modA);</div><div class="line">        <span class="keyword">var</span> modBPath = getModFilePath(modB);</div><div class="line">        <span class="keyword">return</span> modAPath &gt; modBPath ? <span class="number">1</span> : modAPath &lt; modBPath ? <span class="number">-1</span> : <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="comment">// 获取模块源码，开发阶段别用</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getModSrc</span>(<span class="params">mod</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> mod._source &amp;&amp; mod._source._value || <span class="string">''</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    compiler.plugin(<span class="string">"compilation"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">compilation</span>) </span>&#123;</div><div class="line">        compilation.plugin(<span class="string">"chunk-hash"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk, chunkHash</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> source = chunk.modules.sort(compareMod).map(getModSrc).join(<span class="string">''</span>);</div><div class="line">            chunkHash.digest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> md5(source);</div><div class="line">            &#125;;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = ContentHashPlugin;</div></pre></td></tr></table></figure>
<p>此时，pageA.css 修改之后，再也不会影响 pageA.js 的 hash 值。</p>
<p>另外要注意，ExtractTextPlugin 会把 pageA.css 的内容抽取之后，替换该模块的内容 <code>mod._source._value</code> 为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// removed by extract-text-webpack-plugin</div></pre></td></tr></table></figure>
<p>由于每一个 css 模块都对应这段内容，所以不会影响效果。</p>
<p><a href="https://github.com/erm0l0v/webpack-md5-hash" target="_blank" rel="external">erm0l0v/webpack-md5-hash</a> 插件也是为了解决类似问题，但是它其中的『排序』算法是基于模块的 id，而模块的 id 理论上是不稳定的，接下来我们就讨论不稳定的模块 ID 带来的坑。</p>
<h2 id="模块-ID-的坑"><a href="#模块-ID-的坑" class="headerlink" title="模块 ID 的坑"></a>模块 ID 的坑</h2><p>我们简单的把每个文件理解为一个模块（module），在 webpack 处理模块依赖关系时，会给每个模块定义一个 ID，查看 <a href="https://github.com/webpack/webpack/blob/75caa169bcf63c66ab069c38c73c3ab0e873cdc2/lib/Compilation.js#L748" target="_blank" rel="external">webpack/Compilation.js </a> 发现，webpack 根据收集 module 的顺序给每个模块分配递增数字作为 ID，至于『收集的 module 顺序』，在你开发生涯里，这玩意绝对是不稳定！不稳定的！</p>
<h3 id="Module-ID-不稳定怎么了"><a href="#Module-ID-不稳定怎么了" class="headerlink" title="Module ID 不稳定怎么了"></a>Module ID 不稳定怎么了</h3><p>我们的<strong>文件结构</strong>现在长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/src</div><div class="line">	|- pageA.js</div><div class="line">	|- pageB.js</div><div class="line">	|- a.js</div><div class="line">	|- b.js</div><div class="line">	|- c.js</div></pre></td></tr></table></figure>
<p>pageA.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'./a.js'</span>) <span class="comment">// a.js</span></div><div class="line"><span class="built_in">require</span>(<span class="string">'./b.js'</span>) <span class="comment">// b.js</span></div><div class="line"><span class="keyword">var</span> a = <span class="string">'this is pageA'</span>;</div></pre></td></tr></table></figure>
<p>pageB.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'./b.js'</span>) <span class="comment">//  b.js'</span></div><div class="line"><span class="built_in">require</span>(<span class="string">'./c.js'</span>) <span class="comment">// c.js</span></div><div class="line"><span class="keyword">var</span> b = <span class="string">'this is pageB'</span>;</div></pre></td></tr></table></figure>
<p>更新配置，把引用达到 2 次的模块抽取出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  output: &#123;</div><div class="line">        chunkFilename: <span class="string">"[id].[chunkhash:4].bundle.js"</span>,</div><div class="line">	...</div><div class="line">plugins: [</div><div class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">        name: <span class="string">"commons"</span>,</div><div class="line">        minChunks: <span class="number">2</span>,</div><div class="line">        chunks: [<span class="string">"pageA"</span>, <span class="string">"pageB"</span>],</div><div class="line">    &#125;),</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>build build build:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  pageA.1cda.js  262 bytes       0  [emitted]  pageA</div><div class="line">  pageB.0752.js  280 bytes       1  [emitted]  pageB</div><div class="line">commons.14bf.js    3.64 kB       2  [emitted]  commons</div></pre></td></tr></table></figure>
<p>观察 pageB.0752.js，有一段:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">__webpack_require__(<span class="number">2</span>) <span class="comment">//  b.js'</span></div><div class="line">__webpack_require__(<span class="number">3</span>) <span class="comment">// c.js</span></div><div class="line"><span class="keyword">var</span> b = <span class="string">'this is pageB'</span>;</div></pre></td></tr></table></figure>
<p>从上面看出，webpack 构建时给 <code>b.js</code> 的模块 ID 为 <strong>2</strong></p>
<p>这时，我们改一下 <strong>pageA.js</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 移除对 a.js 的依赖</div><div class="line">// require(&apos;./a.js&apos;) // a.js</div><div class="line">require(&apos;./b.js&apos;) // b.js</div><div class="line">var a = &apos;this is pageA&apos;;</div></pre></td></tr></table></figure>
<p>build build build ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  pageA.a945.js  200 bytes       0  [emitted]  pageA</div><div class="line">  pageB.0752.js  271 bytes       1  [emitted]  pageB</div><div class="line">commons.14bf.js    3.65 kB       2  [emitted]  commons</div></pre></td></tr></table></figure>
<p>嗯! 只有 pageA.js 的 hash 变了，挺合理合理，我们进去 pageB.0752.js 看看</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">__webpack_require__(<span class="number">1</span>) <span class="comment">//  b.js'</span></div><div class="line">__webpack_require__(<span class="number">2</span>) <span class="comment">// c.js</span></div><div class="line"><span class="keyword">var</span> b = <span class="string">'this is pageB'</span>;</div></pre></td></tr></table></figure>
<p>看出来了没！这次构建，webpack 给 <code>b.js</code> 的 ID 是 <strong>1</strong>。</p>
<p>我们 pageB.js 的 hash 没变，因为背后依赖的模块内容 (b.js、c.js) 没有变呀，但是此时 pageB.0752.js 的内容确实变了，如果你用 CDN 上传这个文件，<strong>也许</strong>会传不上去，因为文件大小和名称一模一样，就是这个不稳定的模块 ID 给坑的！</p>
<p>怎么解决呢？</p>
<p>第一念头：把原来计算 hash 的方式改一下，就那构建输出后的文件内容来计算？</p>
<p>细想: 不要，明明 pageB 这一次就不用重新上传的，浪费。</p>
<p>比较优雅的思路就是：让模块 ID 给我稳定下来！！！</p>
<h3 id="给我稳定的-Module-ID"><a href="#给我稳定的-Module-ID" class="headerlink" title="给我稳定的 Module ID"></a>给我稳定的 Module ID</h3><h4 id="webpack-1-的官方方案"><a href="#webpack-1-的官方方案" class="headerlink" title="webpack 1 的官方方案"></a>webpack 1 的官方方案</h4><p>webpack 文档提供了几种方案</p>
<ul>
<li><p><a href="http://webpack.github.io/docs/list-of-plugins.html#occurrenceorderplugin" target="_blank" rel="external">OccurrenceOrderPlugin</a>    </p>
<p>  这个插件根据 module 被引用的次数（被 entry 引用、被 chunk 引用）来排序分配 ID，如果你的整个应用的文件依赖是没太多变化，那么模块 ID 就稳定，但是谁能保证呢？</p>
</li>
<li><p><a href="http://webpack.github.io/docs/configuration.html#recordspath-recordsinputpath-recordsoutputpath" target="_blank" rel="external"><code>recordsPath 配置</code></a></p>
<blockquote>
<p>Store/Load compiler state from/to a json file. This will result in persistent ids of modules and chunks.</p>
</blockquote>
<p>  会记录每一次打包的模块的”文件处理路径”使用的 ID，下次打包同样的模块直接使用记录中的 ID:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;node_modules/style-loader/index.js!node_modules/css-loader/index.js!src/b.css&quot;: 9,</div></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>这就要求每个人都得提交这份文件了，港真，我觉得体验很差咯。

另外一旦你修改文件名，或者是增减 loader，原来的路径就无效了，从而再次入坑！
</code></pre><ul>
<li><p><a href="http://webpack.github.io/docs/list-of-plugins.html#dllplugin" target="_blank" rel="external">DllPlugin 和 DllReferencePlugin</a></p>
<p>  原理就是在你打包源码前，你得新建一个构建配置用 <a href="https://github.com/webpack/webpack/tree/master/examples/dll" target="_blank" rel="external">DllPlugin</a> 单独打包生成一份模块文件路径对应的 ID 记录，然后在你的原来配置使用 <a href="https://github.com/webpack/webpack/tree/master/examples/dll-user" target="_blank" rel="external">DllReferencePlugin</a> 引用这份记录，跟 recordsPath 大同小异，但是更高效和稳定，但是这个额外的构建，我觉得不够优雅，至于能快多少呢，我目前还不在意这个速度，另外还是得提交多一份记录文件。</p>
</li>
</ul>
<h4 id="webpack-2-的思路"><a href="#webpack-2-的思路" class="headerlink" title="webpack 2 的思路"></a>webpack 2 的思路</h4><ul>
<li><p><a href="https://github.com/webpack/webpack/blob/master/lib/HashedModuleIdsPlugin.js" target="_blank" rel="external">webpack/HashedModuleIdsPlugin.js at master · webpack/webpack</a></p>
</li>
<li><p><a href="https://github.com/webpack/webpack/blob/master/lib/NamedModulesPlugin.js" target="_blank" rel="external">webpack/NamedModulesPlugin.js at master · webpack/webpack</a></p>
</li>
</ul>
<p>以上两个插件的思路都是用模块对应的文件路径直接作为模块 ID，而不是 webpack 1 中的默认使用数字，另外 webpack 1 不接受非数字作为 模块 ID。</p>
<h4 id="我们的思路"><a href="#我们的思路" class="headerlink" title="我们的思路"></a>我们的思路</h4><p>把模块对应的文件路径通过一个哈希计算映射为数字，用这个全局唯一的数字作为 ID 就解决了，妥妥的！</p>
<p>参考：</p>
<ul>
<li><a href="https://github.com/webpack/webpack/blob/75caa169bcf63c66ab069c38c73c3ab0e873cdc2/lib/Compilation.js#L569,L571" target="_blank" rel="external">webpack/Compilation.js 中暴露的 before-module-ids 钩子</a> </li>
<li><a href="https://github.com/webpack/webpack/blob/54aa3cd0d6167943713491fd5e1110b777336be6/lib/HashedModuleIdsPlugin.js" target="_blank" rel="external">webpack/HashedModuleIdsPlugin.js</a> </li>
</ul>
<p>给出 webpack 1.x 中的解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"></div><div class="line">xx.prototype.apply = function(compiler) &#123;</div><div class="line"></div><div class="line">  function hexToNum(str) &#123;</div><div class="line">    str = str.toUpperCase();</div><div class="line">    var code = &apos;&apos;</div><div class="line">    for (var i = 0; i &lt; str.length; i++) &#123;</div><div class="line">      var c = str.charCodeAt(i) + &apos;&apos;;</div><div class="line">      if ((c + &apos;&apos;).length &lt; 2) &#123;</div><div class="line">        c = &apos;0&apos; + c</div><div class="line">      &#125;</div><div class="line">      code += c</div><div class="line">    &#125;</div><div class="line">    return parseInt(code, 10);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var usedIds = &#123;&#125;;</div><div class="line"></div><div class="line">  function genModuleId(module) &#123;</div><div class="line">    var modulePath = module.libIdent(&#123;</div><div class="line">      context: compiler.options.context</div><div class="line">    &#125;);</div><div class="line">    var id = md5(modulePath);</div><div class="line">    var len = 4;</div><div class="line">    while (usedIds[id.substr(0, len)]) &#123;</div><div class="line">      len++;</div><div class="line">    &#125;</div><div class="line">    id = id.substr(0, len);</div><div class="line">    return hexToNum(id)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  compiler.plugin(&quot;compilation&quot;, function(compilation) &#123;</div><div class="line">    compilation.plugin(&quot;before-module-ids&quot;, function(modules) &#123;</div><div class="line">      modules.forEach(function(module) &#123;</div><div class="line">        if (module.libIdent &amp;&amp; module.id === null) &#123;</div><div class="line">          module.id = genModuleId(module);</div><div class="line">          usedIds[module.id] = true;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>注册钩子的思路跟之前的 content hash 插件差不多，获取到模块文件路径后，通过 md5 计算输出 16 进制的字符串（[0-9A-E]），再把字符串的字符逐个转为 ascii 形式的整数，由于 16 进制字符串只会包含 <code>[0-9A-E]</code>，所以保证单个字符转化的整数是两位就能保证这个算法是有效的。</p>
<p>举例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">path = &apos;/node_module/xxx&apos;</div><div class="line">md5Hash = md5(path) // =&gt; A3E...</div><div class="line">nul = hexToNum(md5Hash) // =&gt; 650369</div></pre></td></tr></table></figure>
<p>这个方案还有些小缺点，就是用模块文件路径作为哈希输入还不是百分百完美，如果文件名改了，那么模块 ID 就 “不稳定了”。其实，可以用模块文件内容作为哈希输入，考虑到效率问题，权衡之下还是用路径好了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了保证 webpack 1.x 生产阶段的文件 hash 值能够完美跟文件内容一一映射，查阅了大量信息，根据目前 github 上讨论的解决方案算是大体解决了问题，但是还不够优雅和完美，于是借鉴 webpack 2 的思路加上一点小技巧，比较优雅地解决了这个问题。</p>
<p>插件放在 Github: <a href="https://github.com/zhenyong/webpack-stable-module-id-and-hash" target="_blank" rel="external">zhenyong/webpack-stable-module-id-and-hash</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/webpack/webpack/issues/1315" target="_blank" rel="external">Vendor chunkhash changes when app code changes · Issue #1315 · webpack/webpack</a></li>
<li><a href="https://github.com/webpack/webpack/issues/1315" target="_blank" rel="external">Vendor chunkhash changes when app code changes · Issue #1315 · webpack/webpack</a></li>
<li><a href="http://www.cnblogs.com/ihardcoder/p/5623411.html" target="_blank" rel="external">Webpack中hash与chunkhash的区别，以及js与css的hash指纹解耦方案 - zhoujunpeng - 博客园</a></li>
<li><a href="http://www.alloyteam.com/2016/01/webpack-use-optimization/" target="_blank" rel="external">webpack使用优化 | Web前端 腾讯AlloyTeam Blog | 愿景: 成为地球卓越的Web团队！</a></li>
</ul>
<hr>
<p><strong>CC BY-NC-SA 3.0 CN</strong></p>
<p>本著作采用 <img alt="署名-非商业性使用-相同方式共享 3.0 中国大陆" style="display:inline-block!important;vertical-align: top;" src="/images/cc-by-nc-sa.svg"> <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="external">署名-非商业性使用-相同方式共享 3.0 中国大陆</a> 进行许可</p>
<p>欢迎转载，但转载请注明来自 <a href="http://zhenyong.site">zhenyong.site</a>，并保持转载后文章内容的完整</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用 webpack 构建输出文件时，通常会给文件名加上 hash，该 hash 值根据文件内容计算得到，只要文件内容不变，hash 就不变，于是就可以利用浏览器缓存来节省下载流量。可是 webpack 提供的 hash 似乎不那么靠谱…&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tech" scheme="http://zhenyong.site/categories/tech/"/>
    
    
      <category term="webpack" scheme="http://zhenyong.site/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Vue 2 相关库的中文翻译</title>
    <link href="http://zhenyong.site/2016/10/07/vue-next-stack-doc/"/>
    <id>http://zhenyong.site/2016/10/07/vue-next-stack-doc/</id>
    <published>2016-10-07T06:15:35.000Z</published>
    <updated>2016-10-07T06:18:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Vue 2 相关库 vue-router@next 和 vuex@next 的中文翻译</p>
</blockquote>
<ul>
<li><a href="http://zhenyong.site/vue-router">vue-router</a></li>
<li><a href="http://zhenyong.site/vuex">vuex</a></li>
</ul>
<hr>
<p><strong>CC BY-NC-SA 3.0 CN</strong></p>
<p>本著作采用 <img alt="署名-非商业性使用-相同方式共享 3.0 中国大陆" style="display:inline-block!important;vertical-align: top;" src="/images/cc-by-nc-sa.svg"> <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="external">署名-非商业性使用-相同方式共享 3.0 中国大陆</a> 进行许可</p>
<p>欢迎转载，但转载请注明来自 <a href="http://zhenyong.site">zhenyong.site</a>，并保持转载后文章内容的完整</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Vue 2 相关库 vue-router@next 和 vuex@next 的中文翻译&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zhenyong.site/vue-router&quot;&gt;vue-router&lt;
    
    </summary>
    
      <category term="tech" scheme="http://zhenyong.site/categories/tech/"/>
    
    
      <category term="vue" scheme="http://zhenyong.site/tags/vue/"/>
    
      <category term="git" scheme="http://zhenyong.site/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>开始折腾 Atom</title>
    <link href="http://zhenyong.site/2016/08/03/starting-atom/"/>
    <id>http://zhenyong.site/2016/08/03/starting-atom/</id>
    <published>2016-08-03T05:05:49.000Z</published>
    <updated>2016-08-05T04:15:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Atom 是 Github 出品，基于 Electron 开发的跨平台编辑器。</p>
</blockquote>
<p>之前是 Sublime 重度使用者，因为 React Native 出了个只支持 Atom 的插件，于是开始折腾 Atom，以前没用是因为它太慢了，一个月卸三次装三次，目前 1.9 版本性能提升了好多，插件都是基于 JS，目前插件数量跟 Sublime 的差不多，毕竟是基于浏览器，使用的技术都是前端熟悉的。</p>
<p>那么，从更换主题开始吧…</p>
<a id="more"></a>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>下面是原来 Sublime 使用的界面主题和语法颜色，很高大上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;theme&quot;: &quot;Material-Theme.sublime-theme&quot;,</div><div class="line">&quot;color_scheme&quot;: &quot;Packages/User/SublimeLinter/Oceanic Next (SL).tmTheme&quot;</div></pre></td></tr></table></figure>
<p>在 Atom 中安装界面主题 <a href="https://atom.io/themes/material-ui" target="_blank" rel="external">material-ui</a> 和语法颜色 <a href="https://atom.io/themes/oceanic-next" target="_blank" rel="external">oceanic-next</a>，文档说的很详细</p>
<h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>使用了上面的主题和颜色后，发现编辑区的背景颜色跟 sublime 用的不一样，因为 Atom 本质上是个 Chrome 浏览，第一个想法就是调出控制台 (alt+cmd+i)，查看这个节点 <code>atom-text-editor</code> 的样式 ，接着按照 <a href="https://atom.io/themes/material-ui" target="_blank" rel="external">material-ui</a> 的文档修改主题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// styles/editor.less</div><div class="line">atom-text-editor &#123;</div><div class="line">	// 注释掉这行就好了</div><div class="line">  // background: @level-3-color;</div><div class="line"></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果擅长前端的童鞋用 Atom 上手会很高效，这玩意就是个浏览器，^_^ ！</p>
<h2 id="插件们"><a href="#插件们" class="headerlink" title="插件们"></a>插件们</h2><ul>
<li><p><a href="https://github.com/sindresorhus/atom-editorconfig" target="_blank" rel="external">EditorConfig</a></p>
<p>  Atom 内置 <code>whitespace</code> 插件会『覆盖』掉 EditorConfig 配置，导致 <code>trim_trailing_whitespace</code> 和 <code>insert_final_newline</code> 在 <code>.editorconfig</code> 中无效，参考 <a href="https://github.com/sindresorhus/atom-editorconfig/issues/3" target="_blank" rel="external">github issue</a><br>  (##2016-08-03##)</p>
</li>
<li><p>Markdown</p>
<ul>
<li><p><a href="https://github.com/atom/markdown-preview" target="_blank" rel="external"><code>markdown-previwe</code></a></p>
<p>内置的 <code>markdown-previwe</code> 很好用，（shift+ctrl+m）打开实时预览，还能设置 github 的样式，很酷</p>
</li>
<li><p><a href="https://github.com/mark-hahn/markdown-scroll-sync" target="_blank" rel="external"><code>markdown-scroll-sync</code></a></p>
<p>让预览视图随着编辑光标位置滚动，滚的很准！</p>
</li>
</ul>
</li>
<li><p><a href="https://atom.io/packages/linter" target="_blank" rel="external">Linter</a></p>
<p>  错误提示的 UI 做的真好</p>
<ul>
<li><p><a href="https://atom.io/packages/linter-eslint" target="_blank" rel="external">linter-eslint</a></p>
</li>
<li><p><a href="https://atom.io/packages/linter-flow" target="_blank" rel="external">linter-flow</a></p>
<p>  如果安装了 <code>nuclide</code> 会引发配置错误提示，参考<a href="https://github.com/facebook/nuclide/issues/387" target="_blank" rel="external">这里</a><br>  问题不大，但是每次出现很烦，所以 Disable <code>linter-flow</code>，反正 <code>nuclide</code> 本身有 <code>nuclide-flow</code> 支持 Flow 检测</p>
</li>
</ul>
</li>
<li><p><a href="https://atom.io/packages/hyperclick" target="_blank" rel="external">hyperclick</a></p>
<p>  点击文本跳转的基础，支持各类扩展跳转，如安装 <code>js-hyperclick</code> 插件支持变量定义跳转等</p>
<ul>
<li><p><a href="https://atom.io/packages/js-hyperclick" target="_blank" rel="external">js-hyperclick</a></p>
<p>JS 点击变量跳转到定义处…强大到远超我想像</p>
</li>
</ul>
</li>
<li><p><a href="https://atom.io/packages/atom-ternjs" target="_blank" rel="external">atom-ternjs</a></p>
<p>  代码智能提示，还支持 ES6，它是会扫描代码作分析的，快赶上 IDE了。</p>
</li>
<li><p><a href="https://atom.io/packages/highlight-selected" target="_blank" rel="external">highlight-selected</a></p>
<p>  选中文本后，高亮其他相同文本，双击变量最实用</p>
</li>
<li><p><a href="https://atom.io/packages/autocomplete-paths" target="_blank" rel="external">autocomplete-paths</a></p>
<p>  require、src 等路径提示</p>
</li>
<li><p><a href="https://atom.io/packages/docblockr" target="_blank" rel="external">docblockr</a></p>
<p>  愉快的写注释文档，包括方法等…</p>
</li>
<li><p><a href="https://atom.io/packages/regex-railroad-diagram" target="_blank" rel="external">regex-railroad-diagram</a></p>
<p>  选中正则之后，展示可视化的匹配路径，酷~</p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https%3A//atom.io/packages/file-icons" target="_blank" rel="external">file-icons</a></p>
<p>  导航区文件图标，图标齐全好看</p>
</li>
<li><p><a href="https://atom.io/packages/emmet" target="_blank" rel="external">emmet</a></p>
<p>  手写 HTML 的神器，有个快捷键会跟 markdown preview 冲突，参考<a href="https://discuss.atom.io/t/keyboard-shortcut-overriding-emmet-and-markdown-preview/14113/7" target="_blank" rel="external">这里</a></p>
</li>
<li><p><a href="https://atom.io/packages/local-history" target="_blank" rel="external">local-history</a></p>
<p>  本地记录文件历史</p>
</li>
<li><p><a href="https://atom.io/packages/pigments" target="_blank" rel="external">pigments</a></p>
<p>  颜色相关工具，包括：把<code>rgb(x,x,x)</code>背景色变成相应颜色，选色…牛</p>
</li>
<li><p><a href="https://atom.io/packages/atom-beautify" target="_blank" rel="external">atom-beautify</a></p>
<p>  代码格式化，支持巨多语言</p>
</li>
<li><p><a href="https://atom.io/packages/auto-update-packages" target="_blank" rel="external">auto-update-packages</a></p>
<p>  自动更新插件，虽然设置里面点一下就可以，但是自动不更好吗</p>
</li>
<li><p><a href="https://atom.io/packages/git-projects" target="_blank" rel="external">git-projects</a></p>
<p>  快速打开本地 git 项目，省得切换一次命令行</p>
</li>
<li><p><a href="https://atom.io/packages/minimap" target="_blank" rel="external">minimap</a></p>
<p>  像 Sublime 那样在右侧有个全景代码小图，支持很多扩展</p>
</li>
<li><p><a href="https://atom.io/packages/language-babel" target="_blank" rel="external">language-babel</a></p>
<p>  语法支持 ES6、JSX、Flow …，还支持预览 babel 或 react 编译结果</p>
</li>
<li><p>(nuclide)[<a href="https://atom.io/packages/nuclide" target="_blank" rel="external">https://atom.io/packages/nuclide</a>]</p>
<p>  帮助开发 ReactNative、Flow 相关项目，装完感觉更像 IDE</p>
<p>  nuclide 的 tree-view 覆盖原来的，所有原来 tree-view 上 git 状态颜色就看不到，参考<a href="https://github.com/facebook/nuclide/issues/260" target="_blank" rel="external">这里</a>，不用 nuclide 的 tree-view，<br>  同时也失去它的 remote file sync 等功能</p>
</li>
<li><p>(open-recent)[<a href="https://atom.io/packages/open-recent" target="_blank" rel="external">https://atom.io/packages/open-recent</a>]</p>
<p>  像 Sublime 的 File -&gt; Open Recent，搞不懂为啥不内置</p>
</li>
<li><p>(react)[<a href="https://atom.io/packages/react" target="_blank" rel="external">https://atom.io/packages/react</a>]</p>
<p>  JSX 语法高亮、格式化…最喜欢的事 HTML-&gt;JSX</p>
</li>
<li><p>(term3)[<a href="https://atom.io/packages/term3" target="_blank" rel="external">https://atom.io/packages/term3</a>]</p>
<p>  终端</p>
</li>
<li><p>(todo-show)[<a href="https://atom.io/packages/todo-show" target="_blank" rel="external">https://atom.io/packages/todo-show</a>]</p>
<p>  找出所有 <code>// TODO</code></p>
</li>
<li><p>(tool-bar)[<a href="https://atom.io/packages/tool-bar" target="_blank" rel="external">https://atom.io/packages/tool-bar</a>]</p>
<p>  让 Atom 支持 toolbar，需要安装其他扩展插件</p>
</li>
<li><p>(Advanced Open File)[<a href="https://atom.io/packages/advanced-open-file" target="_blank" rel="external">https://atom.io/packages/advanced-open-file</a>]</p>
<p>  快速打开硬盘上某个文件，如果不存在则创建，支持相对项目路径，创建多个文件，真方便</p>
</li>
<li><p>(keybinding-resolver)[<a href="https://atom.io/packages/keybinding-resolver" target="_blank" rel="external">https://atom.io/packages/keybinding-resolver</a>]</p>
<p>  查看快捷键对应哪些命令，命令冲突时最好用了</p>
</li>
<li><p>Git</p>
<ul>
<li><p>(git-plus)[<a href="https://atom.io/packages/git-plus" target="_blank" rel="external">https://atom.io/packages/git-plus</a>]</p>
<p>便捷 git 操作</p>
</li>
<li><p>(merge-conflicts)[<a href="https://atom.io/packages/merge-conflicts" target="_blank" rel="external">https://atom.io/packages/merge-conflicts</a>]</p>
<p>merge 冲突的时候，用上它方便逐个修改冲突</p>
</li>
</ul>
</li>
<li><p>(source-preview)[<a href="https://atom.io/packages/source-preview" target="_blank" rel="external">https://atom.io/packages/source-preview</a>]</p>
<p>  转化后的代码预览，是一个基础插件，需要配合其他 provider 插件</p>
</li>
</ul>
<h2 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h2><ul>
<li><p>安装插件速度慢</p>
<p>  在 <code>~/.atom/.apmrc</code> 配置 npm 镜像</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">registry = https://registry.npm.taobao.org</div></pre></td></tr></table></figure>
<p>  或者命令行</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apm config set registry https://registry.npm.taobao.org</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>CC BY-NC-SA 3.0 CN</strong></p>
<p>本著作采用 <img alt="署名-非商业性使用-相同方式共享 3.0 中国大陆" style="display:inline-block!important;vertical-align: top;" src="/images/cc-by-nc-sa.svg"> <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="external">署名-非商业性使用-相同方式共享 3.0 中国大陆</a> 进行许可</p>
<p>欢迎转载，但转载请注明来自 <a href="http://zhenyong.site">zhenyong.site</a>，并保持转载后文章内容的完整</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Atom 是 Github 出品，基于 Electron 开发的跨平台编辑器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前是 Sublime 重度使用者，因为 React Native 出了个只支持 Atom 的插件，于是开始折腾 Atom，以前没用是因为它太慢了，一个月卸三次装三次，目前 1.9 版本性能提升了好多，插件都是基于 JS，目前插件数量跟 Sublime 的差不多，毕竟是基于浏览器，使用的技术都是前端熟悉的。&lt;/p&gt;
&lt;p&gt;那么，从更换主题开始吧…&lt;/p&gt;
    
    </summary>
    
    
      <category term="Atom" scheme="http://zhenyong.site/tags/Atom/"/>
    
  </entry>
  
  <entry>
    <title>Vuex 笔记之 Q &amp; A</title>
    <link href="http://zhenyong.site/2016/07/30/vuex-q-and-a/"/>
    <id>http://zhenyong.site/2016/07/30/vuex-q-and-a/</id>
    <published>2016-07-30T07:16:51.000Z</published>
    <updated>2016-07-30T07:43:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><a href="https://github.com/vuejs/vuex" target="_blank" rel="external">Vuex</a> 借鉴 Flux 开发思想，帮助你用更好的程序架构开发 Vue.js 应用，主要体现在帮你更好地管理状态。</p>
</blockquote>
<p>通过『提问』和『回答』的方式记录 <a href="http://vuex.vuejs.org/en/index.html" target="_blank" rel="external">文档</a> 笔记：</p>
<a id="more"></a>
<h3 id="数据存储在哪里？"><a href="#数据存储在哪里？" class="headerlink" title="数据存储在哪里？"></a>数据存储在哪里？</h3><p>整个应用的状态数据存储在一个单例 store 中</p>
<h3 id="组件怎么获取状态？"><a href="#组件怎么获取状态？" class="headerlink" title="组件怎么获取状态？"></a>组件怎么获取状态？</h3><p>组件要使用状态（getter of state）则在组件引入 vuex 配置，为每个coputed 变量指定一个 getter 方法，方法的第一个参数总是 state，然后返回你要的</p>
<h3 id="怎么修改状态？"><a href="#怎么修改状态？" class="headerlink" title="怎么修改状态？"></a>怎么修改状态？</h3><p>谨记组件的状态 getter 不要做任何直接修改状态的事情，或者是触发其他有副作用的事件等。想管理状态则触发 mutation，真正给 state 动刀的是在 vuex。<br>每当你需要管理状态时，每个改变都可以定义成一个『命令』，叫 Mutation，通过在 store 中定义『命令』和执行器，要改变状态就通过 sotre 发出这个命令。<br>Mutation 强调同步操作，至于你要对管理状态作出异步的操作就得看看 Action</p>
<h3 id="如何异步修改状态"><a href="#如何异步修改状态" class="headerlink" title="如何异步修改状态?"></a>如何异步修改状态?</h3><p>在组件中 vex 配置相关 action，然后该方法就直接在 vm 下可以访问，方法的实现通常是在异步操作中组合一些 mutation，当然，如果 Action 用在同步场景，你可以把 Actions 理解成用于组合 Mutation 的大 Mutation，另外，action 方法的第一个参数总是 store</p>
<h3 id="简单同步操作用-Mutation-还是-Action？"><a href="#简单同步操作用-Mutation-还是-Action？" class="headerlink" title="简单同步操作用 Mutation 还是 Action？"></a>简单同步操作用 Mutation 还是 Action？</h3><p>从语法来说，你喜欢哪个都行，不过统一开发思路，在组件内，只跟 action 打交道，然后action 里面再去转发 mutation，这样开发体验统一，你也无须访问 store，好维护。官方制定的规则也是只用 action。</p>
<h3 id="怎么处理多模块？"><a href="#怎么处理多模块？" class="headerlink" title="怎么处理多模块？"></a>怎么处理多模块？</h3><p>如果应用简单，mutation、action、state 各自定义一个总文件，如果多模块，那么在每个模块定义各自的 这三个部分，借助 vuex store 的 modules 配置，子模块内开发体验跟原来的没差，也不需要关注它是否为一个子模块。</p>
<h3 id="我想要一些回调的钩子啥的，拦截一些state的处理作分析，有吗？"><a href="#我想要一些回调的钩子啥的，拦截一些state的处理作分析，有吗？" class="headerlink" title="我想要一些回调的钩子啥的，拦截一些state的处理作分析，有吗？"></a>我想要一些回调的钩子啥的，拦截一些state的处理作分析，有吗？</h3><p>store 有 middlewares 配置，让你可以拦截所有 mutation，在开发环境可以使用内置的 logger 中间件，打印 mutation ，而且能获得前后的 state 快照。</p>
<h3 id="如果我不遵循潜规则，然后在vuex-以外修改状态，你管得着吗？"><a href="#如果我不遵循潜规则，然后在vuex-以外修改状态，你管得着吗？" class="headerlink" title="如果我不遵循潜规则，然后在vuex 以外修改状态，你管得着吗？"></a>如果我不遵循潜规则，然后在vuex 以外修改状态，你管得着吗？</h3><p>确实管不着，不过开发阶段可以开启 strict 模式，在 mutation 以外地方修改 state 会报错。</p>
<h3 id="我也想遵循潜规则，但是在表单-input-中用-v-model，双向绑定呀，会在-mutation-以外修改-state-呀，怎么办？"><a href="#我也想遵循潜规则，但是在表单-input-中用-v-model，双向绑定呀，会在-mutation-以外修改-state-呀，怎么办？" class="headerlink" title="我也想遵循潜规则，但是在表单 input 中用 v-model，双向绑定呀，会在 mutation 以外修改 state 呀，怎么办？"></a>我也想遵循潜规则，但是在表单 input 中用 v-model，双向绑定呀，会在 mutation 以外修改 state 呀，怎么办？</h3><p>提供三个思路：</p>
<ol>
<li>不要用 v-model，改用 value 绑定显示，注册 input 事件，手动调用 action 更新</li>
<li>如果小 case，就不要让 veux 跟踪，弄个组件自己状态，继续愉快 v-model，vuex 管不到你的状态</li>
<li>保持 v-model，又让 vuex 管，那你定义一个 computed 的值，getter 你懂的，至于 setter 就调用 action</li>
</ol>
<h3 id="我怎么测试-mutation-和-action"><a href="#我怎么测试-mutation-和-action" class="headerlink" title="我怎么测试 mutation 和 action ?"></a>我怎么测试 mutation 和 action ?</h3><p>mutation 比较好测试，就是同步函数，当做工具方法测呗，自己模拟state开测。至于 action 呢，如果依赖了外部 api 会比较麻烦，借助 web pack 的 inject-loader 对每个依赖的外部方法手动 mock（包括请求的数据），是有点麻烦。</p>
<h3 id="还有什么碉堡的要告诉我？"><a href="#还有什么碉堡的要告诉我？" class="headerlink" title="还有什么碉堡的要告诉我？"></a>还有什么碉堡的要告诉我？</h3><p>mutation 和 action 支持热重载。<a href="http://daily.zhihu.com/story/7277143" target="_blank" rel="external">用 vue 可以当上 CTO</a>。</p>
<hr>
<p><strong>CC BY-NC-SA 3.0 CN</strong></p>
<p>本著作采用 <img alt="署名-非商业性使用-相同方式共享 3.0 中国大陆" style="display:inline-block!important;vertical-align: top;" src="/images/cc-by-nc-sa.svg"> <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="external">署名-非商业性使用-相同方式共享 3.0 中国大陆</a> 进行许可</p>
<p>欢迎转载，但转载请注明来自 <a href="http://zhenyong.site">zhenyong.site</a>，并保持转载后文章内容的完整</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; 借鉴 Flux 开发思想，帮助你用更好的程序架构开发 Vue.js 应用，主要体现在帮你更好地管理状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过『提问』和『回答』的方式记录 &lt;a href=&quot;http://vuex.vuejs.org/en/index.html&quot;&gt;文档&lt;/a&gt; 笔记：&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://zhenyong.site/categories/tech/"/>
    
    
      <category term="vue" scheme="http://zhenyong.site/tags/vue/"/>
    
      <category term="vuex" scheme="http://zhenyong.site/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>如何跟踪仓库子目录之 subtree 命令</title>
    <link href="http://zhenyong.site/2016/07/20/folk-git-folder/"/>
    <id>http://zhenyong.site/2016/07/20/folk-git-folder/</id>
    <published>2016-07-20T05:35:03.000Z</published>
    <updated>2016-07-20T17:18:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>想翻译 react 的网站，然后发现 github 仓库中，有关网站部分的源码放在子目录 <code>/docs</code> 下，于是想能否单独 <code>folk</code> 子目录 <code>/docs</code>，而且以后只 <code>pull</code> 这个子目录的更新，于是提交记录就只有该目录下的，我就能专心对比提交然后修改对应翻译。</p>
<a id="more"></a>
<p>通过阅读下列资源</p>
<ul>
<li><a href="http://stackoverflow.com/questions/24577084/forking-a-sub-directory-of-a-repository-on-github-and-making-it-part-of-my-own-r" target="_blank" rel="external">Forking a sub directory … part of my own repo</a></li>
<li><a href="https://lostechies.com/johnteague/2014/04/04/using-git-subtrees-to-split-a-repository/" target="_blank" rel="external">Using Git subtrees to split a repository</a></li>
<li><a href="https://github.com/apenwarr/git-subtree/blob/master/git-subtree.txt" target="_blank" rel="external">git-subtree/git-subtree.txt</a></li>
</ul>
<p>找到一种奇葩解决方法，下面逐步讲解</p>
<p>假设 <code>react</code> 仓库长这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">react.git (master)</div><div class="line">	|---/others</div><div class="line">	|---/docs</div><div class="line">			|-- a.txt</div><div class="line">			|-- b.txt</div></pre></td></tr></table></figure>
<p>我希望我的仓库长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">my.git (master)</div><div class="line">	|---/docs</div><div class="line">			|-- a.txt</div><div class="line">			|-- b.txt</div><div class="line">			</div><div class="line">	|---/docs-cn</div><div class="line">			|-- a.txt</div><div class="line">			|-- b.txt</div></pre></td></tr></table></figure>
<p>其中 <code>/docs</code> 保持跟 react 的 <code>/docs</code> 内容一样，而 <code>/docs-cn</code> 则是我翻译新增的内容</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-准备我的仓库"><a href="#1-准备我的仓库" class="headerlink" title="1. 准备我的仓库"></a>1. 准备我的仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone git@github.com:zhenyong/react-website-cn.git</div><div class="line"></div><div class="line">cd react-website-cn</div></pre></td></tr></table></figure>
<h3 id="2-拉取-react-master-分支"><a href="#2-拉取-react-master-分支" class="headerlink" title="2. 拉取 react master 分支"></a>2. 拉取 react master 分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git remote add react https://github.com/facebook/react.git</div><div class="line"></div><div class="line">git fetch react master:react-master</div></pre></td></tr></table></figure>
<p>自动创建的本地 <code>react-master</code> 分支就相当于 react 库（master分支）</p>
<h3 id="3-分割子目录成新分支"><a href="#3-分割子目录成新分支" class="headerlink" title="3. 分割子目录成新分支"></a>3. 分割子目录成新分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git checkout react-master</div><div class="line">git subtree split --prefix=docs -b react-docs</div><div class="line">git checkout react-docs</div><div class="line">git push origin react-docs</div></pre></td></tr></table></figure>
<p>新的分支 <code>react-docs</code> 包含了 <code>/docs</code> 目录的所有内容，长这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my.git (react-docs)</div><div class="line">		|-- a.txt</div><div class="line">		|-- b.txt</div></pre></td></tr></table></figure>
<h3 id="4-子目录指向-react-docs-分支"><a href="#4-子目录指向-react-docs-分支" class="headerlink" title="4. 子目录指向 react-docs 分支"></a>4. 子目录指向 <code>react-docs</code> 分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git subtree add --prefix=docs --squash origin react-docs</div></pre></td></tr></table></figure>
<p>在当前分支创建 <code>app</code> 目录，引用 origin react-docs 分支，可以理解成子目录作为一个子仓库，实际上 <code>react-docs</code> 的角色就是中转站</p>
<p>此时，我的 master 分支长这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">my.git (master)</div><div class="line">	|---/docs</div><div class="line">			|-- a.txt</div><div class="line">			|-- b.txt</div></pre></td></tr></table></figure>
<p>之后就可以在 master 增加翻译内容</p>
<h3 id="5-更新-react-docs"><a href="#5-更新-react-docs" class="headerlink" title="5. 更新 react-docs"></a>5. 更新 <code>react-docs</code></h3><p>当 react 内容有更新后，拉取 react 最新内容，重新分割</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">git checkout react-master</div><div class="line">git pull react master</div><div class="line"></div><div class="line">git subtree split --prefix=docs --squash \</div><div class="line"> --onto react-docs -b react-docs</div><div class="line"> </div><div class="line"> git checkout react-docs</div><div class="line"> git push origin react-docs</div></pre></td></tr></table></figure>
<p>注意 split 多了一个参数 –onto, 表明再次生成分支时基于原来 <code>react-docs</code> （HEAD）提交记录形成历史纪录</p>
<h3 id="6-我的-master-更新子仓库"><a href="#6-我的-master-更新子仓库" class="headerlink" title="6. 我的 master 更新子仓库"></a>6. 我的 master 更新子仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git subtree pull --prefix=docs --squash origin react-docs</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 <code>react</code> 仓库分离子目录成为新的（中转）仓库，在我的仓库下建立子目录作为子仓库指向中转仓库，从而达到我的 <code>/docs</code> 目录跟踪 <code>react</code> 的<br><code>\docs</code> 目录。</p>
<p>note: 为了演示命令，所以没有设置分支跟踪来简化命令。另外你也可以考虑先 clone react 仓库然后再操作。</p>
<hr>
<p><strong>CC BY-NC-SA 3.0 CN</strong></p>
<p>本著作采用 <img alt="署名-非商业性使用-相同方式共享 3.0 中国大陆" style="display:inline-block!important;vertical-align: top;" src="/images/cc-by-nc-sa.svg"> <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="external">署名-非商业性使用-相同方式共享 3.0 中国大陆</a> 进行许可</p>
<p>欢迎转载，但转载请注明来自 <a href="http://zhenyong.site">zhenyong.site</a>，并保持转载后文章内容的完整</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想翻译 react 的网站，然后发现 github 仓库中，有关网站部分的源码放在子目录 &lt;code&gt;/docs&lt;/code&gt; 下，于是想能否单独 &lt;code&gt;folk&lt;/code&gt; 子目录 &lt;code&gt;/docs&lt;/code&gt;，而且以后只 &lt;code&gt;pull&lt;/code&gt; 这个子目录的更新，于是提交记录就只有该目录下的，我就能专心对比提交然后修改对应翻译。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://zhenyong.site/categories/tech/"/>
    
    
      <category term="git" scheme="http://zhenyong.site/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Flow in Vue</title>
    <link href="http://zhenyong.site/2016/07/06/Flow-in-Vue/"/>
    <id>http://zhenyong.site/2016/07/06/Flow-in-Vue/</id>
    <published>2016-07-06T05:07:31.000Z</published>
    <updated>2016-09-29T11:08:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Facebook 出品的 JS 静态类型检查器</p>
</blockquote>
<p>JS 相关的静态检测，一般人都会想到 Typescript， 配合微软的 Code 编辑器，杠杠的，为何 vue 选用 Flow 呢，作者在知乎作了 <a href="http://www.zhihu.com/question/46397274" target="_blank" rel="external">回答</a></p>
<p><a href="https://flowtype.org/" target="_blank" rel="external">Flow 官网</a></p>
<p><a href="http://zhenyong.site/flowtype">Flow 官网</a>（中文）</p>
<a id="more"></a>
<h2 id="Flow-简单体验"><a href="#Flow-简单体验" class="headerlink" title="Flow 简单体验"></a>Flow 简单体验</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>mac 用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install flow</div></pre></td></tr></table></figure>
<p>然后命令行敲 flow，如果没有反应大概是 brew link 失败了，重新 link 一次就好了</p>
<p>linux 用户通过 npm 安装 <code>flow-bin</code> （全局方便点）</p>
<p>windows 用户目前要使用非官方 build 的版本，<a href="http://www.ocamlpro.com/pub/ocpwin/flow-builds/" target="_blank" rel="external">这里</a></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在项目根目录创建 <code>.flowconfig</code> 空白文件，让 flow 知道这个目录下的文件可以用 flow 检测，当然还可以通过这个文件配置一些规则</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>创建一个 <code>hello.js</code>，第一行 <code>/* @flow */</code> 表明这个文件需要检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* @flow */</div><div class="line"></div><div class="line">function foo(x) &#123;</div><div class="line">  return x * 10;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(&quot;Hello, world!&quot;)</div></pre></td></tr></table></figure>
<p>在跟目录下，执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flow check</div></pre></td></tr></table></figure>
<p>控制台输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">7: foo(&quot;Hello, world!&quot;)</div><div class="line">     ^^^^^^^^^^^^^^^^^^^^ function call</div><div class="line">  4:   return x * 10;</div><div class="line">              ^ string. This type is incompatible with</div><div class="line">  4:   return x * 10;</div><div class="line">              ^^^^^^ number</div></pre></td></tr></table></figure>
<p>这里检测到 <code>foo</code> 方法的参数 <code>x</code> 应该是数字类型，代码中使用了字符串 <code>&quot;Hello, world!&quot;</code> 作为参数就会报错</p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>基本上 Typescript 你能用到的 Flow 都有，例如指定变量类型、函数返回值类型、自定义对象元类型… 参考 <a href="https://flowtype.org/docs/getting-started.html#_" target="_blank" rel="external">官方文档</a></p>
<h2 id="编辑器实时检测"><a href="#编辑器实时检测" class="headerlink" title="编辑器实时检测"></a>编辑器实时检测</h2><p>通常都不会手动执行命令，结合编辑器实时监测，跟之前介绍的 <code>eslint</code> linter 差不多，sublime 安装</p>
<ul>
<li><code>SublimeLinter</code> <a href="http://sublimelinter.readthedocs.org/en/latest/installation.html" target="_blank" rel="external">安装指南</a></li>
<li><code>SublimeLinter-flow</code><a href="https://github.com/SublimeLinter/SublimeLinter-flow" target="_blank" rel="external">安装指南</a></li>
</ul>
<p>效果：</p>
<p><img src="http://ww1.sinaimg.cn/mw690/68ef88dajw1f5nvq1917aj20bc04a0t0.jpg" alt=""></p>
<h2 id="Flow-in-Vue"><a href="#Flow-in-Vue" class="headerlink" title="Flow in Vue"></a>Flow in Vue</h2><h3 id="flowconfig-配置文件"><a href="#flowconfig-配置文件" class="headerlink" title=".flowconfig 配置文件"></a>.flowconfig 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[ignore]</div><div class="line">.*/node_modules/.*</div><div class="line">.*/test/.*</div><div class="line">.*/build/.*</div><div class="line">.*/examples/.*</div><div class="line">.*/benchmarks/.*</div><div class="line"></div><div class="line">[include]</div><div class="line"></div><div class="line">[libs]</div><div class="line">flow</div><div class="line"></div><div class="line">[options]</div><div class="line">module.name_mapper=&apos;^compiler/\(.*\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/compiler/\1&apos;</div><div class="line">module.name_mapper=&apos;^core/\(.*\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/core/\1&apos;</div><div class="line">module.name_mapper=&apos;^shared/\(.*\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/shared/\1&apos;</div><div class="line">module.name_mapper=&apos;^web/\(.*\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/platforms/web/\1&apos;</div><div class="line">module.name_mapper=&apos;^server/\(.*\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/server/\1&apos;</div><div class="line">module.name_mapper=&apos;^entries/\(.*\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/entries/\1&apos;</div><div class="line">module.name_mapper=&apos;^sfc/\(.*\)$&apos; -&gt; &apos;&lt;PROJECT_ROOT&gt;/src/sfc/\1&apos;</div></pre></td></tr></table></figure>
<p>解释下各个配置意思</p>
<ul>
<li><code>ignore</code>：表示该以下匹配到的文件夹都不需要检测</li>
<li><code>include</code>：这里是空白，默认所有文件，如果检测项目根目录以外就要罗列在这里</li>
<li><code>libs</code>: 表示使用目录 /flow 下的接口定义文件</li>
<li><code>options</code>: 第一行配置的效果是，当<code>require(&#39;compiler/xx/yy&#39;)</code> 时把加载路径重定向到 <code>项目路径/src/compiler/xx/yy</code></li>
</ul>
<h3 id="接口类型文件"><a href="#接口类型文件" class="headerlink" title="接口类型文件"></a>接口类型文件</h3><p>回一下 Java 或者其它强类型 OO 语言，当你调用类中没定义的方法时，或者调用方法的参数个数不对时，IDE就会提醒，那么接口类型文件就有点这个意思，让你的类也有这么一个规则文件可以用来校验开发者的代码，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// /flow/component.js</div><div class="line"></div><div class="line">declare interface Component &#123;</div><div class="line">  // constructor information</div><div class="line">  static cid: number</div><div class="line">	...省略...</div><div class="line">  $data: Object;</div><div class="line">  $options: ComponentOptions;</div><div class="line">...省略...</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><code>Component</code> 是 vue 内部一个类，通过这个接口类型文件表明组件类有哪些成员，哪些静态属性等等，特别要看到 <code>ComponentOptions</code>，这对应到另一个接口类型。</p>
<p>通过这种接口类型，某种意义上，你就有了强类型 OO 语言写代码的一些优点。</p>
<p>当然 vue 的类型文件远不止这用到这点点，更多细节就不一一介绍</p>
<p>语法部分请参照<a href="https://flowtype.org/" target="_blank" rel="external">Flow 官网</a>或者我翻译的<a href="http://zhenyong.site/flowtype">中文网站</a></p>
<p>至于 vue 为什么选用 flow 而不用相对流行的 TypeScript，参考他的知乎回答 <a href="http://www.zhihu.com/question/46397274" target="_blank" rel="external">Vue 2.0 为什么选用 Flow 进行静态代码检查而不是直接使用 TypeScript?</a>。</p>
<p>而我个人也觉得 Flow 有些很实用的场景，例如你无需学习成本，就能用上他的智能检测，解决 null 相关的潜在问题。</p>
<hr>
<p><strong>CC BY-NC-SA 3.0 CN</strong></p>
<p>本著作采用 <img alt="署名-非商业性使用-相同方式共享 3.0 中国大陆" style="display:inline-block!important;vertical-align: top;" src="/images/cc-by-nc-sa.svg"> <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="external">署名-非商业性使用-相同方式共享 3.0 中国大陆</a> 进行许可</p>
<p>欢迎转载，但转载请注明来自 <a href="http://zhenyong.site">zhenyong.site</a>，并保持转载后文章内容的完整</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Facebook 出品的 JS 静态类型检查器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JS 相关的静态检测，一般人都会想到 Typescript， 配合微软的 Code 编辑器，杠杠的，为何 vue 选用 Flow 呢，作者在知乎作了 &lt;a href=&quot;http://www.zhihu.com/question/46397274&quot;&gt;回答&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://flowtype.org/&quot;&gt;Flow 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zhenyong.site/flowtype&quot;&gt;Flow 官网&lt;/a&gt;（中文）&lt;/p&gt;
    
    </summary>
    
    
      <category term="flow" scheme="http://zhenyong.site/tags/flow/"/>
    
  </entry>
  
  <entry>
    <title>ESLint in Vue</title>
    <link href="http://zhenyong.site/2016/07/05/ESLint-in-Vue/"/>
    <id>http://zhenyong.site/2016/07/05/ESLint-in-Vue/</id>
    <published>2016-07-05T04:02:35.000Z</published>
    <updated>2016-07-09T11:37:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>ESLint 一个 JavaScript 代码的静态检测工具</p>
</blockquote>
<a id="more"></a>
<p>相比之前比较流行的 <strong>JSHint</strong>，<strong>ESLint</strong> 扩展性强、配置灵活、支持 ES6 …</p>
<ul>
<li><a href="http://eslint.org/" target="_blank" rel="external">ESLint 官网</a></li>
<li><a href="http://eslint.cn/" target="_blank" rel="external">ESLint 中文</a></li>
</ul>
<p>参考官网安装 eslint 就可以在命令行检测 js 文件的语法错误</p>
<h2 id="编辑器中使用-ESLint"><a href="#编辑器中使用-ESLint" class="headerlink" title="编辑器中使用 ESLint"></a>编辑器中使用 ESLint</h2><p>在实际开发中，更多是配合编辑器（Sublime Text）一起使用，在编写代码的时候使用 eslint 实时检测代码，并且提醒错误的部分，下面展示安装使用过程</p>
<h3 id="1-安装ESLint-Node-模块"><a href="#1-安装ESLint-Node-模块" class="headerlink" title="1. 安装ESLint Node 模块"></a>1. 安装ESLint Node 模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g eslint</div></pre></td></tr></table></figure>
<h3 id="2-安装-Sublime-Text-插件"><a href="#2-安装-Sublime-Text-插件" class="headerlink" title="2. 安装 Sublime Text 插件"></a>2. 安装 Sublime Text 插件</h3><ul>
<li><code>SublimeLinter</code> <a href="http://sublimelinter.readthedocs.org/en/latest/installation.html" target="_blank" rel="external">安装指南</a></li>
<li><code>SublimeLinter-contrib-eslint</code> <a href="https://github.com/roadhump/SublimeLinter-eslint#plugin-installation" target="_blank" rel="external">安装指南</a></li>
</ul>
<p><code>SublimeLinter</code> 是一个 <em>代码检测基础框架</em>，当需要具体检测方案则要安装对应的库，例如需要 eslint 监测则安装 <code>SublimeLinter-contrib-eslint</code></p>
<h3 id="3-创建配置文件"><a href="#3-创建配置文件" class="headerlink" title="3. 创建配置文件"></a>3. 创建配置文件</h3><p>在项目根目录下创建 <code>.eslintrc</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;root&quot;: true,</div><div class="line">  &quot;rules&quot;: &#123;</div><div class="line">    &quot;eqeqeq&quot;: &quot;error&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的 <code>&quot;eqeqeq&quot;: &quot;warn&quot;</code> 规则表明，如果代码中出现 <code>==</code> <code>!=</code>来比较则会出现错误提醒，建议使用 <code>===</code> <code>!==</code></p>
<p>这个简单配置只是为了演示，具体参考 </p>
<ul>
<li><a href="http://eslint.org/docs/user-guide/configuring#using-configuration-files" target="_blank" rel="external">配置指南</a></li>
<li><a href="http://eslint.cn/docs/user-guide/configuring#using-configuration-files" target="_blank" rel="external">配置指南（中文）</a></li>
</ul>
<p>这样，写代码的时候就能实时检测错误并且提醒了：</p>
<p><img src="http://ww3.sinaimg.cn/large/68ef88dajw1f5j17wvklzj207802nwef.jpg" alt=""></p>
<h2 id="Vue-的-ESLint"><a href="#Vue-的-ESLint" class="headerlink" title="Vue 的 ESLint"></a>Vue 的 ESLint</h2><h3 id="eslintignore-文件"><a href="#eslintignore-文件" class="headerlink" title=".eslintignore 文件"></a>.eslintignore 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">flow</div><div class="line">dist</div><div class="line">packages</div></pre></td></tr></table></figure>
<p>表明 eslint 检测时，要忽略掉这些目录</p>
<h3 id="eslintrc-文件"><a href="#eslintrc-文件" class="headerlink" title=".eslintrc 文件"></a>.eslintrc 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;root&quot;: true,</div><div class="line">  &quot;parser&quot;: &quot;babel-eslint&quot;,</div><div class="line">  &quot;extends&quot;: &quot;vue&quot;,</div><div class="line">  &quot;plugins&quot;: [&quot;flow-vars&quot;],</div><div class="line">  &quot;rules&quot;: &#123;</div><div class="line">    &quot;flow-vars/define-flow-type&quot;: 1,</div><div class="line">    &quot;flow-vars/use-flow-type&quot;: 1</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面逐个配置解释：</p>
<ul>
<li><code>&quot;root&quot;: true</code></li>
</ul>
<p>对于某个文件使用哪个配置文件，按照以下顺序查找</p>
<ol>
<li>在待检测文件的同一目录查找配置文件</li>
<li>往上逐层父级目录查找，直到发现一个有 <code>&quot;root&quot;: true</code> 的</li>
<li>使用项目根目录配置文件</li>
<li>使用系统全局配置文件</li>
</ol>
<ul>
<li><code>&quot;parser&quot;: &quot;babel-eslint&quot;</code></li>
</ul>
<p>使用非默认的 <code>babel-eslint</code> 作为代码解析器，同时你需要安装相应 node 模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -save-dev babel-eslint</div></pre></td></tr></table></figure>
<p>这样 eslint 就能识别 babel 语法的代码</p>
<ul>
<li><code>&quot;extends&quot;: &quot;vue&quot;</code></li>
</ul>
<p>官方或者第三方提供了一些配置模板，你只需继承则可以使用他们的模板配置，这里继承了 <code>vue</code> 意味着你需要安装 <code>eslint-config-vue</code> 这个 node 模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -save-dev eslint-config-vue</div></pre></td></tr></table></figure>
<ul>
<li><code>&quot;plugins&quot;: [&quot;flow-vars&quot;]</code></li>
</ul>
<p>让 eslint 支持 <code>Flow Script</code> 的全局注解等语法，同时你也要安装对应的 node 模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -save-dev eslint-plugin-flow-vars</div></pre></td></tr></table></figure>
<ul>
<li><code>&quot;rules&quot;:{xx}</code></li>
</ul>
<p>一些主要的配置都在 <code>&quot;extends&quot;: &quot;vue&quot;</code> 解决了，flow 插件部分的配置则在这里另外定义</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 ESLint 保持团队编码风格统一，减少低级错误，真的很赞！</p>
<p>另外推荐 <a href="https://github.com/airbnb/javascript" target="_blank" rel="external"><code>airbnb</code> 的 ES6 编码风格</a>，它有配套的 eslint 模板，很赞</p>
<p>对于英文实在不行的，那就参考 <a href="https://github.com/gf-rd/es6-coding-style" target="_blank" rel="external">ECMAScript6 编码规范–广发证券前端团队</a></p>
<hr>
<p><strong>CC BY-NC-SA 3.0 CN</strong></p>
<p>本著作采用 <img alt="署名-非商业性使用-相同方式共享 3.0 中国大陆" style="display:inline-block!important;vertical-align: top;" src="/images/cc-by-nc-sa.svg"> <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="external">署名-非商业性使用-相同方式共享 3.0 中国大陆</a> 进行许可</p>
<p>欢迎转载，但转载请注明来自 <a href="http://zhenyong.site">zhenyong.site</a>，并保持转载后文章内容的完整</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ESLint 一个 JavaScript 代码的静态检测工具&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tech" scheme="http://zhenyong.site/categories/tech/"/>
    
    
      <category term="vue" scheme="http://zhenyong.site/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Babel in Vue</title>
    <link href="http://zhenyong.site/2016/07/04/Babel-in-Vue/"/>
    <id>http://zhenyong.site/2016/07/04/Babel-in-Vue/</id>
    <published>2016-07-04T02:36:26.000Z</published>
    <updated>2016-07-13T08:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Babel 是一个 JavaScript 编译器</p>
</blockquote>
<p>Vue 的所有模块代码都是用了 ES6 的语法，可是大多数浏览器对 ES6 支持不够，所以需要先把源码（ES6）转化为浏览器能够识别执行的代码（ES5），而这个过程就需要用到 <code>Babel</code> 这个工具</p>
<a id="more"></a>
<h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><p>对照 Babel 的 <a href="https://babeljs.io/" target="_blank" rel="external">官网</a>  首页的指南简单玩一下：</p>
<ul>
<li>安装</li>
</ul>
<p>安装 babel 命令行工具 （官网是在项目下安装，这里全局安装）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g babel-cli</div></pre></td></tr></table></figure>
<p>这样就能在命令行下启动 babel</p>
<p>另外，我们还要告诉 babel 使用哪种转码规则，这里使用 <a href="http://babeljs.io/docs/plugins/preset-es2015/" target="_blank" rel="external">ES2015 preset</a>。在项目下创建 <code>.babelrc</code> 文件</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"presets"</span>: [<span class="string">"es2015"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后还要安装对应转码规则包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-preset-es2015</div></pre></td></tr></table></figure>
<ul>
<li>测试</li>
</ul>
<p>创建 js 代码文件 <code>test.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hello = () =&gt; &#123;</div><div class="line">  <span class="keyword">let</span> name = <span class="string">'peter'</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'hello '</span> + name)</div><div class="line">&#125;</div><div class="line"></div><div class="line">hello()</div></pre></td></tr></table></figure>
<p>转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">babel test.js --out-file test.compiled.js</div></pre></td></tr></table></figure>
<p>生成 <code>test.compiled.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">var hello = function hello() &#123;</div><div class="line">  var name = &apos;peter&apos;;</div><div class="line">  console.log(&apos;hello &apos; + name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">hello();</div></pre></td></tr></table></figure>
<p>现在就可以在浏览器运行这段代码了</p>
<p>更多关于 babel 或者 es6 的知识可以参考官网，或者还有下面中文网站：</p>
<ul>
<li><a href="http://www.infoq.com/cn/es6-in-depth/" target="_blank" rel="external">InfoQ 专栏 - 深入浅出 ES6</a></li>
<li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">阮一峰 - ECMAScript 6 入门</a></li>
</ul>
<h2 id="vue-中使用"><a href="#vue-中使用" class="headerlink" title="vue 中使用"></a>vue 中使用</h2><p>vue 中在构建代码的时候结合 webpack 和 babel 相关插件使用，。。。</p>
<p>//TODO 在 webpack 部分一起写</p>
<hr>
<p><strong>CC BY-NC-SA 3.0 CN</strong></p>
<p>本著作采用 <img alt="署名-非商业性使用-相同方式共享 3.0 中国大陆" style="display:inline-block!important;vertical-align: top;" src="/images/cc-by-nc-sa.svg"> <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="external">署名-非商业性使用-相同方式共享 3.0 中国大陆</a> 进行许可</p>
<p>欢迎转载，但转载请注明来自 <a href="http://zhenyong.site">zhenyong.site</a>，并保持转载后文章内容的完整</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Babel 是一个 JavaScript 编译器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vue 的所有模块代码都是用了 ES6 的语法，可是大多数浏览器对 ES6 支持不够，所以需要先把源码（ES6）转化为浏览器能够识别执行的代码（ES5），而这个过程就需要用到 &lt;code&gt;Babel&lt;/code&gt; 这个工具&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="http://zhenyong.site/categories/tech/"/>
    
    
      <category term="vue" scheme="http://zhenyong.site/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>EditorConfig in Vue</title>
    <link href="http://zhenyong.site/2016/07/03/EditorConfig-in-Vue/"/>
    <id>http://zhenyong.site/2016/07/03/EditorConfig-in-Vue/</id>
    <published>2016-07-03T09:23:26.000Z</published>
    <updated>2016-07-05T07:14:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>EditorConfig 可以帮助开发者在不同的编辑器和IDE之间定义和维护一致的代码风格</p>
</blockquote>
<a id="more"></a>
<p>某些编辑器使用 EditorConfig 则需要安装对应的插件，Sublime Text 的话就安装 EditorConfig </p>
<p>源码中的配置文件 <code>.editorconfig</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">root = true</div><div class="line"></div><div class="line">[*]</div><div class="line">charset = utf-8</div><div class="line">indent_style = space</div><div class="line">indent_size = 2</div><div class="line">end_of_line = lf</div><div class="line">insert_final_newline = true</div><div class="line">trim_trailing_whitespace = true</div></pre></td></tr></table></figure>
<p>解释一下这份配置的意思:</p>
<ul>
<li><code>root = true</code></li>
</ul>
<p>当打开一个文件时，EditorConfig 插件在文件的目录和其每一级父目录查找 .editorconfig 文件，直到有一个配置文件包含 root = true</p>
<p>EditorConfig 配置文件从上往下读取，并且路径最近的文件最后被读取，匹配到的配置按照读取顺序应用在代码上，最接近代码文件的属性优先级最高</p>
<ul>
<li><p><code>[*]</code><br>表示对所有文件文件使用 editorconfig，也可以指定某种文件格式</p>
</li>
<li><p><code>charset = utf-8</code></p>
</li>
</ul>
<p>设置文件编码格式为 utf-8</p>
<ul>
<li><code>indent_style = space</code></li>
</ul>
<p>所有的缩进使用空格，包括 tab 键产生的空白</p>
<ul>
<li><code>indent_size = 2</code></li>
</ul>
<p>设置整数表示规定每级缩进的列数</p>
<ul>
<li><code>end_of_line = lf</code></li>
</ul>
<p>统一设置换行符，不同操作系统默认使用不同的换行符</p>
<p>windows 是 crlf，即 <code>\r\n</code></p>
<p>unix 则是 lf ，即 <code>\n</code></p>
<ul>
<li><code>insert_final_newline = true</code></li>
</ul>
<p>文件都以一个空白行结尾</p>
<ul>
<li><code>trim_trailing_whitespace = true</code></li>
</ul>
<p>除去换行行首的任意空白字符</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="http://editorconfig.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://www.alloyteam.com/2014/12/editor-config/" target="_blank" rel="external">EditorConfig介绍（译）</a></li>
</ul>
<hr>
<p><strong>CC BY-NC-SA 3.0 CN</strong></p>
<p>本著作采用 <img alt="署名-非商业性使用-相同方式共享 3.0 中国大陆" style="display:inline-block!important;vertical-align: top;" src="/images/cc-by-nc-sa.svg"> <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="external">署名-非商业性使用-相同方式共享 3.0 中国大陆</a> 进行许可</p>
<p>欢迎转载，但转载请注明来自 <a href="http://zhenyong.site">zhenyong.site</a>，并保持转载后文章内容的完整</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;EditorConfig 可以帮助开发者在不同的编辑器和IDE之间定义和维护一致的代码风格&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="tech" scheme="http://zhenyong.site/categories/tech/"/>
    
    
      <category term="vue" scheme="http://zhenyong.site/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 源码工具链介绍</title>
    <link href="http://zhenyong.site/2016/07/03/Vue-%E6%BA%90%E7%A0%81%E5%B7%A5%E5%85%B7%E9%93%BE%E4%BB%8B%E7%BB%8D/"/>
    <id>http://zhenyong.site/2016/07/03/Vue-源码工具链介绍/</id>
    <published>2016-07-03T08:55:15.000Z</published>
    <updated>2016-07-13T08:50:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 Vue 源码中使用到的工具，例如编辑器插件、打包工具、测试工具等等</p>
<p>有部分工具我平时也在用，为了系统地介绍，我也当做小白去学习</p>
<p>本人和小右平常使用的编辑器都是 <a href="https://www.sublimetext.com/3" target="_blank" rel="external">Sublime Text 3</a></p>
<ul>
<li><a href="http://zhenyong.site/2016/07/03/EditorConfig-in-Vue/">EditorConfig</a></li>
<li><a href="http://zhenyong.site/2016/07/04/Babel-in-Vue/">Babel</a></li>
<li><a href="http://zhenyong.site/2016/07/05/ESLint-in-Vue/">ESLint</a></li>
<li><a href="http://zhenyong.site/2016/07/06/Flow-in-Vue/">Flow</a></li>
</ul>
<hr>
<p><strong>CC BY-NC-SA 3.0 CN</strong></p>
<p>本著作采用 <img alt="署名-非商业性使用-相同方式共享 3.0 中国大陆" style="display:inline-block!important;vertical-align: top;" src="/images/cc-by-nc-sa.svg"> <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank" rel="external">署名-非商业性使用-相同方式共享 3.0 中国大陆</a> 进行许可</p>
<p>欢迎转载，但转载请注明来自 <a href="http://zhenyong.site">zhenyong.site</a>，并保持转载后文章内容的完整</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍 Vue 源码中使用到的工具，例如编辑器插件、打包工具、测试工具等等&lt;/p&gt;
&lt;p&gt;有部分工具我平时也在用，为了系统地介绍，我也当做小白去学习&lt;/p&gt;
&lt;p&gt;本人和小右平常使用的编辑器都是 &lt;a href=&quot;https://www.sublimetext.com/3&quot; 
    
    </summary>
    
      <category term="tech" scheme="http://zhenyong.site/categories/tech/"/>
    
    
      <category term="vue" scheme="http://zhenyong.site/tags/vue/"/>
    
  </entry>
  
</feed>
